"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Base_1 = __importDefault(require("./Base"));
const Token_1 = __importDefault(require("./models/Token"));
const Token_2 = __importDefault(require("./Token"));
const ArbERC20_json_1 = __importDefault(require("@hop-protocol/core/abi/static/ArbERC20.json"));
const ArbitrumGlobalInbox_json_1 = __importDefault(require("@hop-protocol/core/abi/static/ArbitrumGlobalInbox.json"));
const L1_HomeAMBNativeToErc20_json_1 = __importDefault(require("@hop-protocol/core/abi/static/L1_HomeAMBNativeToErc20.json"));
const L1_OptimismTokenBridge_json_1 = __importDefault(require("@hop-protocol/core/abi/static/L1_OptimismTokenBridge.json"));
const L1_PolygonPosRootChainManager_json_1 = __importDefault(require("@hop-protocol/core/abi/static/L1_PolygonPosRootChainManager.json"));
const L1_xDaiForeignOmniBridge_json_1 = __importDefault(require("@hop-protocol/core/abi/static/L1_xDaiForeignOmniBridge.json"));
const L2_OptimismTokenBridge_json_1 = __importDefault(require("@hop-protocol/core/abi/static/L2_OptimismTokenBridge.json"));
const L2_PolygonChildERC20_json_1 = __importDefault(require("@hop-protocol/core/abi/static/L2_PolygonChildERC20.json"));
const L2_xDaiToken_json_1 = __importDefault(require("@hop-protocol/core/abi/static/L2_xDaiToken.json"));
const models_1 = require("./models");
const ethers_1 = require("ethers");
const utils_1 = require("ethers/lib/utils");
const config_1 = require("./config");
/**
 * Class reprensenting Canonical Token Bridge.
 * @namespace CanonicalBridge
 */
class CanonicalBridge extends Base_1.default {
    /**
     * @desc Instantiates Canonical Token Bridge.
     * Returns a new Canonical Token Bridge instance.
     * @param {String} network - L1 network name (e.g. 'mainnet', 'kovan', 'goerli')
     * @param {Object} signer - Ethers `Signer` for signing transactions.
     * @param {Object} token - Token symbol or model
     * @param {Object} chain - Chain model
     * @returns {Object} CanonicalBridge SDK instance.
     * @example
     *```js
     *import { CanonicalHop, Chain, Token } from '@hop-protocol/sdk'
     *import { Wallet } from 'ethers'
     *
     *const signer = new Wallet(privateKey)
     *const bridge = new CanonicalBridge('kovan', signer, Token.USDC, Chain.Optimism)
     *```
     */
    constructor(network, signer, token, chain, chainProviders) {
        super(network, signer, chainProviders);
        if (!token) {
            throw new Error('token symbol is required');
        }
        token = this.toTokenModel(token);
        chain = this.toChainModel(chain);
        if (signer) {
            this.signer = signer;
        }
        this.chain = chain;
        if (token instanceof Token_1.default) {
            this.tokenSymbol = token.symbol;
        }
        else if (typeof token === 'string') {
            this.tokenSymbol = token;
        }
        else {
            console.log('token: ', token);
            throw new Error('Invalid token');
        }
    }
    /**
     * @desc Return address of L1 canonical token bridge.
     * @return {String} L1 canonical token bridge address
     */
    get address() {
        if (!this.tokenSymbol) {
            return null;
        }
        if (!this.chain) {
            return null;
        }
        return this.getL1CanonicalBridgeAddress(this.tokenSymbol, this.chain);
    }
    /**
     * @desc Returns canonical bridge instance with signer connected. Used for adding or changing signer.
     * @param {Object} signer - Ethers `Signer` for signing transactions.
     * @returns {Object} New CanonicalBridge SDK instance with connected signer.
     */
    connect(signer) {
        return new CanonicalBridge(this.network, signer, this.tokenSymbol, this.chain, this.chainProviders);
    }
    getDepositApprovalAddress(chain) {
        chain = this.chain || this.toChainModel(chain);
        let spender = this.getL1CanonicalBridgeAddress(this.tokenSymbol, chain);
        if (chain.equals(models_1.Chain.Polygon)) {
            spender = this.getL1PosErc20PredicateAddress(this.tokenSymbol, chain);
        }
        return spender;
    }
    /**
     * @desc Sends transaction to approve tokens for canonical token bridge deposit.
     * Will only send approval transaction if necessary.
     * @param {Object} amount - Token amount to approve.
     * @param {Object} chain - Chain model.
     * @returns {Object} Ethers transaction object.
     */
    approveDeposit(amount, chain) {
        return __awaiter(this, void 0, void 0, function* () {
            amount = amount.toString();
            if (chain) {
                chain = this.toChainModel(chain);
            }
            else {
                chain = this.chain;
            }
            const provider = yield this.getSignerOrProvider(models_1.Chain.Ethereum);
            const l1CanonicalToken = this.getL1Token().connect(provider);
            const spender = this.getDepositApprovalAddress(chain);
            if (!spender) {
                throw new Error(`token "${this.tokenSymbol}" on chain "${chain.slug}" is unsupported`);
            }
            return l1CanonicalToken.approve(spender, amount);
        });
    }
    /**
     * @desc Sends transaction to canonical token bridge to deposit tokens into L2.
     * @param {Object} amount - Token amount to deposit.
     * @param {Object} chain - Chain model.
     * @returns {Object} Ethers transaction object.
     */
    deposit(amount, chain) {
        return __awaiter(this, void 0, void 0, function* () {
            amount = amount.toString();
            if (chain) {
                chain = this.toChainModel(chain);
            }
            else {
                chain = this.chain;
            }
            if (!chain) {
                throw new Error('chain is required');
            }
            const recipient = yield this.getSignerAddress();
            const bridgeAddress = this.getL1CanonicalBridgeAddress(this.tokenSymbol, chain);
            if (!bridgeAddress) {
                throw new Error(`token "${this.tokenSymbol}" on chain "${chain.slug}" is unsupported`);
            }
            const provider = yield this.getSignerOrProvider(models_1.Chain.Ethereum);
            const tokenAddress = this.getL1CanonicalTokenAddress(this.tokenSymbol, models_1.Chain.Ethereum);
            if (!tokenAddress) {
                throw new Error(`token "${this.tokenSymbol}" on chain "${chain.slug}" is unsupported`);
            }
            if (chain.equals(models_1.Chain.xDai)) {
                const bridge = yield this.getContract(bridgeAddress, L1_xDaiForeignOmniBridge_json_1.default, provider);
                // await this.checkMaxTokensAllowed(chain, bridge, amount)
                return bridge.relayTokens(tokenAddress, recipient, amount, {
                    // xDai requires a higher gas limit
                    gasLimit: 300000
                });
            }
            else if (chain.equals(models_1.Chain.Optimism)) {
                const l2TokenAddress = this.getL2CanonicalTokenAddress(this.tokenSymbol, chain);
                if (!l2TokenAddress) {
                    throw new Error(`token "${this.tokenSymbol}" on chain "${chain.slug}" is unsupported`);
                }
                const bridge = yield this.getContract(bridgeAddress, L1_OptimismTokenBridge_json_1.default, provider);
                yield this.checkMaxTokensAllowed(chain, bridge, amount);
                return bridge.deposit(tokenAddress, l2TokenAddress, recipient, amount);
            }
            else if (chain.equals(models_1.Chain.Arbitrum)) {
                const arbChain = this.getArbChainAddress(this.tokenSymbol, chain);
                const bridge = yield this.getContract(bridgeAddress, ArbitrumGlobalInbox_json_1.default, provider);
                yield this.checkMaxTokensAllowed(chain, bridge, amount);
                return bridge.depositERC20Message(arbChain, tokenAddress, recipient, amount);
            }
            else if (chain.equals(models_1.Chain.Polygon)) {
                const bridgeAddress = this.getL1PosRootChainManagerAddress(this.tokenSymbol, chain);
                if (!bridgeAddress) {
                    throw new Error(`token "${this.tokenSymbol}" on chain "${chain.slug}" is unsupported`);
                }
                const bridge = yield this.getContract(bridgeAddress, L1_PolygonPosRootChainManager_json_1.default, provider);
                const coder = ethers_1.ethers.utils.defaultAbiCoder;
                const payload = coder.encode(['uint256'], [amount]);
                return bridge.depositFor(recipient, tokenAddress, payload);
            }
            else {
                throw new Error('not implemented');
            }
        });
    }
    getWithdrawApprovalAddress(chain) {
        chain = this.chain || this.toChainModel(chain);
        let spender = this.getL2CanonicalBridgeAddress(this.tokenSymbol, chain);
        if (chain.equals(models_1.Chain.Polygon)) {
            spender = this.getL1PosErc20PredicateAddress(this.tokenSymbol, chain);
        }
        return spender;
    }
    /**
     * @desc Sends transaction to approve tokens for canonical token bridge withdrawal.
     * Will only send approval transaction if necessary.
     * @param {Object} amount - Token amount to approve.
     * @returns {Object} Ethers transaction object.
     */
    approveWithdraw(amount) {
        return __awaiter(this, void 0, void 0, function* () {
            amount = amount.toString();
            // no approval needed
            if (this.chain.equals(models_1.Chain.Polygon)) {
                return;
            }
            const provider = yield this.getSignerOrProvider(models_1.Chain.Ethereum);
            const token = this.getCanonicalToken(this.chain).connect(provider);
            const spender = this.getWithdrawApprovalAddress(this.chain);
            if (!spender) {
                throw new Error(`token "${this.tokenSymbol}" on chain "${this.chain.slug}" is unsupported`);
            }
            return token.approve(spender, amount);
        });
    }
    /**
     * @desc Sends transaction to L2 canonical token bridge to withdraw tokens into L1.
     * @param {Object} amount - Token amount to withdraw.
     * @param {Object} chain - Chain model.
     * @returns {Object} Ethers transaction object.
     */
    withdraw(amount, chain) {
        return __awaiter(this, void 0, void 0, function* () {
            amount = amount.toString();
            if (chain) {
                chain = this.toChainModel(chain);
            }
            else {
                chain = this.chain;
            }
            if (!chain) {
                throw new Error('chain is required');
            }
            const recipient = yield this.getSignerAddress();
            const provider = yield this.getSignerOrProvider(chain);
            if (chain.equals(models_1.Chain.xDai)) {
                const bridgeAddress = this.getL2CanonicalBridgeAddress(this.tokenSymbol, chain);
                if (!bridgeAddress) {
                    throw new Error(`token "${this.tokenSymbol}" on chain "${chain.slug}" is unsupported`);
                }
                const tokenAddress = this.getL2CanonicalTokenAddress(this.tokenSymbol, chain);
                if (!tokenAddress) {
                    throw new Error(`token "${this.tokenSymbol}" on chain "${chain.slug}" is unsupported`);
                }
                const bridge = yield this.getContract(tokenAddress, L2_xDaiToken_json_1.default, provider);
                return bridge.transferAndCall(bridgeAddress, amount, '0x', {
                    // xDai requires a higher gas limit
                    gasLimit: 400000
                });
            }
            else if (chain.equals(models_1.Chain.Optimism)) {
                const bridgeAddress = this.getL2CanonicalBridgeAddress(this.tokenSymbol, chain);
                if (!bridgeAddress) {
                    throw new Error(`token "${this.tokenSymbol}" on chain "${chain.slug}" is unsupported`);
                }
                const l1TokenAddress = this.getL1CanonicalTokenAddress(this.tokenSymbol, models_1.Chain.Ethereum);
                if (!l1TokenAddress) {
                    throw new Error(`token "${this.tokenSymbol}" on chain "${models_1.Chain.Ethereum.slug}" is unsupported`);
                }
                const tokenAddress = this.getL2CanonicalTokenAddress(this.tokenSymbol, chain);
                if (!tokenAddress) {
                    throw new Error(`token "${this.tokenSymbol}" on chain "${chain.slug}" is unsupported`);
                }
                const bridge = yield this.getContract(bridgeAddress, L2_OptimismTokenBridge_json_1.default, provider);
                return bridge.withdraw(l1TokenAddress, tokenAddress, amount, {
                    // optimism requires a high gas limit and 0 gas price
                    gasLimit: 1000000,
                    gasPrice: 0
                });
            }
            else if (chain.equals(models_1.Chain.Arbitrum)) {
                const bridgeAddress = this.getL2CanonicalTokenAddress(this.tokenSymbol, chain);
                if (!bridgeAddress) {
                    throw new Error(`token "${this.tokenSymbol}" on chain "${chain.slug}" is unsupported`);
                }
                const bridge = yield this.getContract(bridgeAddress, ArbERC20_json_1.default, provider);
                return bridge.withdraw(recipient, amount);
            }
            else if (chain.equals(models_1.Chain.Polygon)) {
                const tokenAddress = this.getL2CanonicalTokenAddress(this.tokenSymbol, chain);
                if (!tokenAddress) {
                    throw new Error(`token "${this.tokenSymbol}" on chain "${chain.slug}" is unsupported`);
                }
                const token = yield this.getContract(tokenAddress, L2_PolygonChildERC20_json_1.default, provider);
                return token.withdraw(amount);
            }
            else {
                throw new Error('not implemented');
            }
        });
    }
    /**
     * @desc Sends transaction to finalize withdrawal.
     * This call is necessary on Polygon to finalize L2 withdrawal into L1 on
     * certain chains. Will only send transaction if necessary.
     * @param {String} txHash - Transaction hash proving token burn on L2.
     * @param {Object} chain - Chain model.
     * @returns {Object} Ethers transaction object.
     */
    exit(txHash, chain) {
        return __awaiter(this, void 0, void 0, function* () {
            chain = this.toChainModel(chain);
            const recipient = yield this.getSignerAddress();
            const { MaticPOSClient } = require('@maticnetwork/maticjs');
            const Web3 = require('web3');
            const posRootChainManagerAddress = this.getL1PosRootChainManagerAddress(this.tokenSymbol, chain);
            if (!posRootChainManagerAddress) {
                throw new Error(`token "${this.tokenSymbol}" on chain "${chain.slug}" is unsupported`);
            }
            const posERC20PredicateAddress = this.getL1PosErc20PredicateAddress(this.tokenSymbol, chain);
            if (!posERC20PredicateAddress) {
                throw new Error(`token "${this.tokenSymbol}" on chain "${chain.slug}" is unsupported`);
            }
            const maticPOSClient = new MaticPOSClient({
                network: models_1.Chain.Ethereum.chainId === 1 ? 'mainnet' : 'testnet',
                maticProvider: new Web3.providers.HttpProvider(models_1.Chain.Polygon.rpcUrl),
                parentProvider: new Web3.providers.HttpProvider(models_1.Chain.Ethereum.rpcUrl),
                posRootChainManager: posRootChainManagerAddress,
                posERC20Predicate: posERC20PredicateAddress
            });
            const tx = yield maticPOSClient.exitERC20(txHash, {
                from: recipient,
                encodeAbi: true
            });
            const provider = yield this.getSignerOrProvider(chain);
            return provider.sendTransaction({
                to: tx.to,
                value: tx.value,
                data: tx.data,
                gasLimit: tx.gas
            });
        });
    }
    /**
     * @desc Checks if the amount of tokens is allowed by the canonical token bridge,
     * otherwise throw an error.
     * @param {Object} chain - Chain model.
     * @param {Object} canonicalBridge - Ethers contract object for canonical token bridge.
     * @param {Object} amount - Token amount.
     */
    checkMaxTokensAllowed(chain, canonicalBridge, amount) {
        return __awaiter(this, void 0, void 0, function* () {
            if (chain.equals(models_1.Chain.xDai)) {
                const l1CanonicalToken = this.getL1Token();
                const maxPerTx = yield (canonicalBridge === null || canonicalBridge === void 0 ? void 0 : canonicalBridge.maxPerTx());
                const formattedMaxPerTx = Number((0, utils_1.formatUnits)(maxPerTx.toString(), l1CanonicalToken.decimals));
                const formattedAmount = Number((0, utils_1.formatUnits)(amount.toString(), l1CanonicalToken.decimals));
                if (formattedAmount > formattedMaxPerTx) {
                    throw new Error(`Max allowed by xDai Bridge is ${formattedMaxPerTx} tokens`);
                }
            }
        });
    }
    // xDai AMB bridge
    getAmbBridge(chain) {
        return __awaiter(this, void 0, void 0, function* () {
            chain = this.toChainModel(chain || this.chain);
            if (chain.equals(models_1.Chain.Ethereum)) {
                const address = this.getL1AmbBridgeAddress(this.tokenSymbol, models_1.Chain.xDai);
                const provider = yield this.getSignerOrProvider(models_1.Chain.Ethereum);
                return this.getContract(address, L1_HomeAMBNativeToErc20_json_1.default, provider);
            }
            const address = this.getL2AmbBridgeAddress(this.tokenSymbol, models_1.Chain.xDai);
            const provider = yield this.getSignerOrProvider(models_1.Chain.xDai);
            return this.getContract(address, L1_HomeAMBNativeToErc20_json_1.default, provider);
        });
    }
    getL2CanonicalBridge() {
        return __awaiter(this, void 0, void 0, function* () {
            const address = this.getL2CanonicalBridgeAddress(this.tokenSymbol, this.chain);
            if (!address) {
                throw new Error(`token "${this.tokenSymbol}" on chain "${this.chain.slug}" is unsupported`);
            }
            const provider = yield this.getSignerOrProvider(this.chain);
            let abi;
            if (this.chain.equals(models_1.Chain.Polygon)) {
                abi = L2_PolygonChildERC20_json_1.default;
            }
            else if (this.chain.equals(models_1.Chain.xDai)) {
                abi = L2_xDaiToken_json_1.default;
            }
            else if (this.chain.equals(models_1.Chain.Arbitrum)) {
                abi = ArbERC20_json_1.default;
            }
            else if (this.chain.equals(models_1.Chain.Optimism)) {
                abi = L2_OptimismTokenBridge_json_1.default;
            }
            return this.getContract(address, abi, provider);
        });
    }
    getL1CanonicalBridge() {
        return __awaiter(this, void 0, void 0, function* () {
            const address = this.getL1CanonicalBridgeAddress(this.tokenSymbol, this.chain);
            if (!address) {
                throw new Error(`token "${this.tokenSymbol}" on chain "${this.chain.slug}" is unsupported`);
            }
            const provider = yield this.getSignerOrProvider(models_1.Chain.Ethereum);
            let abi;
            if (this.chain.equals(models_1.Chain.Polygon)) {
                abi = L1_PolygonPosRootChainManager_json_1.default;
            }
            else if (this.chain.equals(models_1.Chain.xDai)) {
                abi = L1_xDaiForeignOmniBridge_json_1.default;
            }
            else if (this.chain.equals(models_1.Chain.Arbitrum)) {
                abi = ArbitrumGlobalInbox_json_1.default;
            }
            else if (this.chain.equals(models_1.Chain.Optimism)) {
                abi = L1_OptimismTokenBridge_json_1.default;
            }
            return this.getContract(address, abi, provider);
        });
    }
    // ToDo: Remove duplicated logic after refactoring token getters
    getL1Token() {
        return this.toCanonicalToken(this.tokenSymbol, this.network, models_1.Chain.Ethereum);
    }
    getCanonicalToken(chain) {
        return this.toCanonicalToken(this.tokenSymbol, this.network, chain);
    }
    getL2HopToken(chain) {
        return this.toHopToken(this.tokenSymbol, this.network, chain);
    }
    toCanonicalToken(token, network, chain) {
        token = this.toTokenModel(token);
        chain = this.toChainModel(chain);
        const { name, symbol, decimals, image } = config_1.metadata.tokens[network][token.canonicalSymbol];
        let address;
        if (chain.isL1) {
            const { l1CanonicalToken } = this.getL1CanonicalBridgeAddress(token.symbol, chain.slug);
            address = l1CanonicalToken;
        }
        else {
            const { l2CanonicalToken } = this.getL2CanonicalTokenAddress(token.symbol, chain.slug);
            address = l2CanonicalToken;
        }
        return new Token_2.default(network, chain, address, decimals, symbol, name, image);
    }
    toHopToken(token, network, chain) {
        chain = this.toChainModel(chain);
        if (chain.isL1) {
            throw new Error('Hop tokens do not exist on layer 1');
        }
        let tokenSymbol;
        if (typeof token === 'string') {
            tokenSymbol = token;
        }
        else {
            tokenSymbol = token.symbol;
        }
        const { name, symbol, decimals, image } = config_1.metadata.tokens[network][tokenSymbol];
        const { l2HopBridgeToken } = this.getL2HopBridgeTokenAddress(tokenSymbol, chain.slug);
        return new Token_2.default(network, chain, l2HopBridgeToken, decimals, symbol, name, image);
    }
}
exports.default = CanonicalBridge;
