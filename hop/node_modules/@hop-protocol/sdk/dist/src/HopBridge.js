"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const AMM_1 = __importDefault(require("./AMM"));
const Base_1 = __importDefault(require("./Base"));
const Chain_1 = __importDefault(require("./models/Chain"));
const Token_1 = __importDefault(require("./Token"));
const Token_2 = __importDefault(require("./models/Token"));
const isomorphic_fetch_1 = __importDefault(require("isomorphic-fetch"));
const L1_ERC20_Bridge_json_1 = __importDefault(require("@hop-protocol/core/abi/generated/L1_ERC20_Bridge.json"));
const L1_HomeAMBNativeToErc20_json_1 = __importDefault(require("@hop-protocol/core/abi/static/L1_HomeAMBNativeToErc20.json"));
const L2_AmmWrapper_json_1 = __importDefault(require("@hop-protocol/core/abi/generated/L2_AmmWrapper.json"));
const L2_Bridge_json_1 = __importDefault(require("@hop-protocol/core/abi/generated/L2_Bridge.json"));
const ethers_1 = require("ethers");
const constants_1 = require("./constants");
const priceFeed_1 = require("./priceFeed");
const config_1 = require("./config");
const utils_1 = require("ethers/lib/utils");
const contracts_1 = require("@eth-optimism/contracts");
/**
 * Class reprensenting Hop bridge.
 * @namespace HopBridge
 */
class HopBridge extends Base_1.default {
    /**
     * @desc Instantiates Hop Bridge.
     * Returns a new Hop Bridge instance.
     * @param {String} network - L1 network name (e.g. 'mainnet', 'kovan', 'goerli')
     * @param {Object} signer - Ethers `Signer` for signing transactions.
     * @param {Object} token - Token symbol or model
     * @param {Object} sourceChain - Source chain model
     * @param {Object} destinationChain - Destination chain model
     * @returns {Object} HopBridge SDK instance.
     * @example
     *```js
     *import { HopBridge, Chain, Token } from '@hop-protocol/sdk'
     *import { Wallet } from 'ethers'
     *
     *const signer = new Wallet(privateKey)
     *const bridge = new HopBridge('kovan', signer, Token.USDC, Chain.Optimism, Chain.xDai)
     *```
     */
    constructor(network, signer, token, chainProviders) {
        super(network, signer, chainProviders);
        /** Default deadline for transfers */
        this.defaultDeadlineMinutes = 7 * 24 * 60; // 1 week
        if (token instanceof Token_1.default || token instanceof Token_2.default) {
            this.tokenSymbol = token.symbol;
        }
        else if (typeof token === 'string') {
            this.tokenSymbol = token;
        }
        if (!token) {
            throw new Error('token is required');
        }
        this.priceFeed = new priceFeed_1.PriceFeed();
    }
    /**
     * @desc Returns hop bridge instance with signer connected. Used for adding or changing signer.
     * @param {Object} signer - Ethers `Signer` for signing transactions.
     * @returns {Object} New HopBridge SDK instance with connected signer.
     * @example
     *```js
     *import { Hop, Token } from '@hop-protocol/sdk'
     *import { Wallet } from 'ethers'
     *
     *const signer = new Wallet(privateKey)
     *let hop = new Hop()
     * // ...
     *const bridge = hop.bridge(Token.USDC).connect(signer)
     *```
     */
    connect(signer) {
        return new HopBridge(this.network, signer, this.tokenSymbol, this.chainProviders);
    }
    getL1Token() {
        return this.toCanonicalToken(this.tokenSymbol, this.network, Chain_1.default.Ethereum);
    }
    getCanonicalToken(chain) {
        return this.toCanonicalToken(this.tokenSymbol, this.network, chain);
    }
    getL2HopToken(chain) {
        return this.toHopToken(this.tokenSymbol, this.network, chain);
    }
    toCanonicalToken(token, network, chain) {
        token = this.toTokenModel(token);
        chain = this.toChainModel(chain);
        let { name, symbol, decimals, image } = config_1.metadata.tokens[network][token.canonicalSymbol];
        if (chain.equals(Chain_1.default.xDai) && token.symbol === 'DAI') {
            symbol = 'XDAI';
        }
        let address;
        if (chain.isL1) {
            address = this.getL1CanonicalTokenAddress(token.symbol, chain);
        }
        else {
            address = this.getL2CanonicalTokenAddress(token.symbol, chain);
        }
        return new Token_1.default(network, chain, address, decimals, symbol, name, image, this.signer, this.chainProviders);
    }
    toHopToken(token, network, chain) {
        chain = this.toChainModel(chain);
        token = this.toTokenModel(token);
        if (chain.isL1) {
            throw new Error('Hop tokens do not exist on layer 1');
        }
        const { name, symbol, decimals, image } = config_1.metadata.tokens[network][token.canonicalSymbol];
        const address = this.getL2HopBridgeTokenAddress(token.symbol, chain);
        return new Token_1.default(network, chain, address, decimals, `h${token.canonicalSymbol}`, `Hop ${name}`, image, this.signer, this.chainProviders);
    }
    /**
     * @desc Approve and send tokens to another chain. This will make an approval
     * transaction if not enough allowance.
     * @param {String} tokenAmount - Token amount to send denominated in smallest unit.
     * @param {Object} sourceChain - Source chain model.
     * @param {Object} destinationChain - Destination chain model.
     * @returns {Object} Ethers Transaction object.
     * @example
     *```js
     *import { Hop, Token } from '@hop-protocol/sdk'
     *
     *const hop = new Hop()
     *const bridge = hop.connect(signer).bridge(Token.USDC)
     *\// send 1 USDC token from Optimism -> xDai
     *const tx = await bridge.send('1000000000000000000', Chain.Optimism, Chain.xDai)
     *console.log(tx.hash)
     *```
     */
    approveAndSend(tokenAmount, sourceChain, destinationChain, options) {
        return __awaiter(this, void 0, void 0, function* () {
            // ToDo: Add approval
            return this.sendHandler(tokenAmount, sourceChain, destinationChain, true, options);
        });
    }
    /**
     * @desc Send tokens to another chain.
     * @param {String} tokenAmount - Token amount to send denominated in smallest unit.
     * @param {Object} sourceChain - Source chain model.
     * @param {Object} destinationChain - Destination chain model.
     * @returns {Object} Ethers Transaction object.
     * @example
     *```js
     *import { Hop, Chain, Token } from '@hop-protocol/sdk'
     *
     *const hop = new Hop()
     *const bridge = hop.connect(signer).bridge(Token.USDC)
     *\// send 1 USDC token from Optimism -> xDai
     *const tx = await bridge.send('1000000000000000000', Chain.Optimism, Chain.xDai)
     *console.log(tx.hash)
     *```
     */
    send(tokenAmount, sourceChain, destinationChain, options) {
        return __awaiter(this, void 0, void 0, function* () {
            tokenAmount = ethers_1.BigNumber.from(tokenAmount.toString());
            if (!sourceChain) {
                sourceChain = this.sourceChain;
            }
            if (!destinationChain) {
                destinationChain = this.destinationChain;
            }
            if (!sourceChain) {
                throw new Error('source chain is required');
            }
            if (!destinationChain) {
                throw new Error('destination chain is required');
            }
            sourceChain = this.toChainModel(sourceChain);
            destinationChain = this.toChainModel(destinationChain);
            if (options === null || options === void 0 ? void 0 : options.estimateGasCostOnly) {
                options.estimateGasOnly = true;
            }
            if (!(options === null || options === void 0 ? void 0 : options.estimateGasOnly)) {
                const availableLiquidity = yield this.getFrontendAvailableLiquidity(sourceChain, destinationChain);
                const requiredLiquidity = yield this.getRequiredLiquidity(tokenAmount, sourceChain);
                const isAvailable = availableLiquidity.gte(requiredLiquidity);
                if (!isAvailable) {
                    throw new Error('Insufficient liquidity available by bonder. Try again in a few minutes');
                }
            }
            const result = yield this.sendHandler(tokenAmount, sourceChain, destinationChain, false, options);
            if (options === null || options === void 0 ? void 0 : options.estimateGasCostOnly) {
                const estimatedGasLimit = result;
                const gasPrice = yield sourceChain.provider.getGasPrice();
                return gasPrice.mul(estimatedGasLimit);
            }
            return result;
        });
    }
    getSendEstimatedGasLimit(tokenAmount, sourceChain, destinationChain, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            options.estimateGasOnly = true;
            return this.send(tokenAmount, sourceChain, destinationChain, options);
        });
    }
    getSendEstimatedGasCost(tokenAmount, sourceChain, destinationChain, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            options.estimateGasCostOnly = true;
            return this.send(tokenAmount, sourceChain, destinationChain, options);
        });
    }
    // ToDo: Docs
    getSendApprovalAddress(sourceChain, destinationChain, isHTokenTransfer = false) {
        sourceChain = this.toChainModel(sourceChain);
        destinationChain = this.toChainModel(destinationChain);
        if (sourceChain.equals(Chain_1.default.Ethereum)) {
            return this.getL1BridgeAddress(this.tokenSymbol, sourceChain);
        }
        const ammWrapperAddress = this.getL2AmmWrapperAddress(this.tokenSymbol, sourceChain);
        const l2BridgeAddress = this.getL2BridgeAddress(this.tokenSymbol, sourceChain);
        return isHTokenTransfer ? l2BridgeAddress : ammWrapperAddress;
    }
    // ToDo: Docs
    sendHToken(tokenAmount, sourceChain, destinationChain, options) {
        return __awaiter(this, void 0, void 0, function* () {
            tokenAmount = tokenAmount.toString();
            if (!sourceChain) {
                throw new Error('source chain is required');
            }
            if (!destinationChain) {
                throw new Error('destination chain is required');
            }
            return this.sendHTokenHandler(tokenAmount.toString(), sourceChain, destinationChain, options);
        });
    }
    // ToDo: Docs
    getTokenSymbol() {
        return this.tokenSymbol;
    }
    // ToDo: Docs
    getTokenImage() {
        var _a;
        return (_a = this.getL1Token()) === null || _a === void 0 ? void 0 : _a.image;
    }
    // ToDo: Docs
    getSendData(amountIn, sourceChain, destinationChain, deadline) {
        return __awaiter(this, void 0, void 0, function* () {
            amountIn = ethers_1.BigNumber.from(amountIn);
            sourceChain = this.toChainModel(sourceChain);
            destinationChain = this.toChainModel(destinationChain);
            const hTokenAmount = yield this.calcToHTokenAmount(amountIn, sourceChain);
            const amountOutWithoutFeePromise = this.calcFromHTokenAmount(hTokenAmount, destinationChain);
            const amountInNoSlippage = ethers_1.BigNumber.from(1000);
            const amountOutNoSlippagePromise = this.getAmountOut(amountInNoSlippage, sourceChain, destinationChain);
            const bonderFeePromise = this.getBonderFee(amountIn, sourceChain, destinationChain);
            const destinationTxFeePromise = this.getDestinationTransactionFee(sourceChain, destinationChain);
            const [amountOutWithoutFee, amountOutNoSlippage, bonderFee, destinationTxFee] = yield Promise.all([
                amountOutWithoutFeePromise,
                amountOutNoSlippagePromise,
                bonderFeePromise,
                destinationTxFeePromise
            ]);
            const amountOut = yield this.calcFromHTokenAmount(hTokenAmount, destinationChain);
            // adjustedFee is the fee in the canonical token after adjusting for the hToken price.
            const adjustedBonderFee = yield this.calcFromHTokenAmount(bonderFee, destinationChain);
            const adjustedDestinationTxFee = yield this.calcFromHTokenAmount(destinationTxFee, destinationChain);
            const totalFee = adjustedBonderFee.add(adjustedDestinationTxFee);
            const sourceToken = this.getCanonicalToken(sourceChain);
            const destToken = this.getCanonicalToken(destinationChain);
            const rate = this.getRate(amountIn, amountOutWithoutFee, sourceToken, destToken);
            const marketRate = this.getRate(amountInNoSlippage, amountOutNoSlippage, sourceToken, destToken);
            const priceImpact = this.getPriceImpact(rate, marketRate);
            const lpFees = yield this.getLpFees(amountIn, sourceChain, destinationChain);
            let estimatedReceived = amountOut;
            if (totalFee.gt(0)) {
                estimatedReceived = estimatedReceived.sub(totalFee);
            }
            if (estimatedReceived.lt(0)) {
                estimatedReceived = ethers_1.BigNumber.from(0);
            }
            return {
                amountOut,
                rate,
                priceImpact,
                requiredLiquidity: hTokenAmount,
                lpFees,
                adjustedBonderFee,
                adjustedDestinationTxFee,
                totalFee,
                estimatedReceived
            };
        });
    }
    // ToDo: Docs
    getAmmData(chain, amountIn, isToHToken, slippageTolerance) {
        return __awaiter(this, void 0, void 0, function* () {
            chain = this.toChainModel(chain);
            amountIn = ethers_1.BigNumber.from(amountIn);
            const canonicalToken = this.getCanonicalToken(chain);
            const hToken = this.getL2HopToken(chain);
            const sourceToken = isToHToken ? canonicalToken : hToken;
            const destToken = isToHToken ? hToken : canonicalToken;
            const amountInNoSlippage = ethers_1.BigNumber.from(1000);
            let amountOut;
            let amountOutNoSlippage;
            if (isToHToken) {
                amountOut = yield this.calcToHTokenAmount(amountIn, chain);
                amountOutNoSlippage = yield this.calcToHTokenAmount(amountInNoSlippage, chain);
            }
            else {
                amountOut = yield this.calcFromHTokenAmount(amountIn, chain);
                amountOutNoSlippage = yield this.calcFromHTokenAmount(amountInNoSlippage, chain);
            }
            const rate = this.getRate(amountIn, amountOut, sourceToken, destToken);
            const marketRate = this.getRate(amountInNoSlippage, amountOutNoSlippage, sourceToken, destToken);
            const priceImpact = this.getPriceImpact(rate, marketRate);
            const oneDestBN = ethers_1.ethers.utils.parseUnits('1', sourceToken.decimals);
            const slippageToleranceBps = slippageTolerance * 100;
            const minBps = Math.ceil(10000 - slippageToleranceBps);
            const amountOutMin = amountOut.mul(minBps).div(10000);
            // Divide by 10000 at the end so that the amount isn't floored at 0
            const lpFee = ethers_1.BigNumber.from(constants_1.LpFeeBps);
            const lpFeeBN = (0, utils_1.parseUnits)(lpFee.toString(), destToken.decimals);
            const lpFeeAmount = amountIn
                .mul(lpFeeBN)
                .div(oneDestBN)
                .div(10000);
            return {
                rate,
                priceImpact,
                amountOutMin,
                lpFeeAmount
            };
        });
    }
    getBonderFee(amountIn, sourceChain, destinationChain) {
        return __awaiter(this, void 0, void 0, function* () {
            sourceChain = this.toChainModel(sourceChain);
            destinationChain = this.toChainModel(destinationChain);
            return this.getMinBonderFee(amountIn.toString(), sourceChain, destinationChain);
        });
    }
    getTotalFee(amountIn, sourceChain, destinationChain, deadline) {
        return __awaiter(this, void 0, void 0, function* () {
            const { totalFee } = yield this.getSendData(amountIn, sourceChain, destinationChain, deadline);
            return totalFee;
        });
    }
    getLpFees(amountIn, sourceChain, destinationChain) {
        return __awaiter(this, void 0, void 0, function* () {
            sourceChain = this.toChainModel(sourceChain);
            destinationChain = this.toChainModel(destinationChain);
            let lpFeeBpsBn = ethers_1.BigNumber.from(0);
            if (!sourceChain.isL1) {
                lpFeeBpsBn = lpFeeBpsBn.add(constants_1.LpFeeBps);
            }
            if (!destinationChain.isL1) {
                lpFeeBpsBn = lpFeeBpsBn.add(constants_1.LpFeeBps);
            }
            amountIn = ethers_1.BigNumber.from(amountIn);
            const lpFees = amountIn.mul(lpFeeBpsBn).div(10000);
            return lpFees;
        });
    }
    getDestinationTransactionFee(sourceChain, destinationChain) {
        return __awaiter(this, void 0, void 0, function* () {
            sourceChain = this.toChainModel(sourceChain);
            destinationChain = this.toChainModel(destinationChain);
            if (sourceChain === null || sourceChain === void 0 ? void 0 : sourceChain.equals(Chain_1.default.Ethereum)) {
                return ethers_1.BigNumber.from(0);
            }
            const canonicalToken = this.getCanonicalToken(sourceChain);
            const chainNativeToken = this.getChainNativeToken(destinationChain);
            const chainNativeTokenPrice = yield this.priceFeed.getPriceByTokenSymbol(chainNativeToken.symbol);
            const tokenPrice = yield this.priceFeed.getPriceByTokenSymbol(canonicalToken.symbol);
            const rate = chainNativeTokenPrice / tokenPrice;
            let gasPrice = yield destinationChain.provider.getGasPrice();
            let { gasLimit: bondTransferGasLimit, data, to } = yield this.getBondWithdrawalEstimatedGas(destinationChain);
            // Arbitrum returns a gasLimit & gasPriceBid of 2x what is generally paid
            if (destinationChain.equals(Chain_1.default.Arbitrum)) {
                gasPrice = gasPrice.div(2);
                bondTransferGasLimit = bondTransferGasLimit.div(2);
            }
            let txFeeEth = gasPrice.mul(bondTransferGasLimit);
            const oneEth = ethers_1.ethers.utils.parseEther('1');
            const rateBN = ethers_1.ethers.utils.parseUnits(rate.toFixed(canonicalToken.decimals), canonicalToken.decimals);
            if (destinationChain.equals(Chain_1.default.Optimism)) {
                try {
                    const l1FeeInWei = yield this.getOptimismL1Fee();
                    txFeeEth = txFeeEth.add(l1FeeInWei);
                }
                catch (err) {
                    console.error(err);
                }
            }
            let fee = txFeeEth.mul(rateBN).div(oneEth);
            let multiplier = ethers_1.BigNumber.from(0);
            if (destinationChain.equals(Chain_1.default.Ethereum) ||
                destinationChain.equals(Chain_1.default.Optimism) ||
                destinationChain.equals(Chain_1.default.Arbitrum)) {
                multiplier = ethers_1.ethers.utils.parseEther(constants_1.GasPriceMultiplier);
            }
            if (multiplier.gt(0)) {
                fee = fee.mul(multiplier).div(oneEth);
            }
            return fee;
        });
    }
    getOptimismL1Fee() {
        return __awaiter(this, void 0, void 0, function* () {
            const chain = this.toChainModel(Chain_1.default.Optimism);
            const gasPrice = yield chain.provider.getGasPrice();
            const { gasLimit, data, to } = yield this.getBondWithdrawalEstimatedGas(chain);
            const ovmGasPriceOracle = (0, contracts_1.getContractFactory)('OVM_GasPriceOracle')
                .attach(contracts_1.predeploys.OVM_GasPriceOracle).connect(chain.provider);
            const serializedTx = (0, utils_1.serializeTransaction)({
                value: (0, utils_1.parseEther)('0'),
                gasPrice,
                gasLimit,
                to,
                data
            });
            const l1FeeInWei = yield ovmGasPriceOracle.getL1Fee(serializedTx);
            return l1FeeInWei;
        });
    }
    getBondWithdrawalEstimatedGas(destinationChain) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let destinationBridge;
                if (destinationChain.isL1) {
                    destinationBridge = yield this.getL1Bridge();
                }
                else {
                    destinationBridge = yield this.getL2Bridge(destinationChain);
                }
                destinationBridge = destinationBridge.connect(destinationChain.provider);
                const bonder = this.getBonderAddress();
                const amount = ethers_1.BigNumber.from(10);
                const amountOutMin = ethers_1.BigNumber.from(0);
                const bonderFee = ethers_1.BigNumber.from(1);
                const deadline = this.defaultDeadlineSeconds;
                const transferNonce = `0x${'0'.repeat(64)}`;
                const recipient = `0x${'1'.repeat(40)}`;
                const attemptSwap = this.shouldAttemptSwap(amountOutMin, deadline);
                if (attemptSwap && !destinationChain.isL1) {
                    const payload = [
                        recipient,
                        amount,
                        transferNonce,
                        bonderFee,
                        amountOutMin,
                        deadline,
                        {
                            from: bonder
                        }
                    ];
                    const tx = yield destinationBridge.populateTransaction.bondWithdrawalAndDistribute(...payload);
                    const gasLimit = yield destinationBridge.estimateGas.bondWithdrawalAndDistribute(...payload);
                    return Object.assign({ gasLimit }, tx);
                }
                else {
                    const payload = [
                        recipient,
                        amount,
                        transferNonce,
                        bonderFee,
                        {
                            from: bonder
                        }
                    ];
                    const tx = yield destinationBridge.populateTransaction.bondWithdrawal(...payload);
                    const gasLimit = yield destinationBridge.estimateGas.bondWithdrawal(...payload);
                    return Object.assign({ gasLimit }, tx);
                }
            }
            catch (err) {
                console.error(err, {
                    destinationChain
                });
                let bondTransferGasLimit = constants_1.BondTransferGasLimit.Ethereum;
                if (destinationChain.equals(Chain_1.default.Optimism)) {
                    bondTransferGasLimit = constants_1.BondTransferGasLimit.Optimism;
                }
                else if (destinationChain.equals(Chain_1.default.Arbitrum)) {
                    bondTransferGasLimit = constants_1.BondTransferGasLimit.Arbitrum;
                }
                return {
                    gasLimit: ethers_1.BigNumber.from(bondTransferGasLimit)
                };
            }
        });
    }
    /**
     * @desc Estimate token amount out.
     * @param {String} tokenAmountIn - Token amount input.
     * @param {Object} sourceChain - Source chain model.
     * @param {Object} destinationChain - Destination chain model.
     * @returns {Object} Amount as BigNumber.
     * @example
     *```js
     *import { Hop, Chain Token } from '@hop-protocol/sdk'
     *
     *const hop = new Hop()
     *const bridge = hop.connect(signer).bridge(Token.USDC)
     *const amountOut = await bridge.getAmountOut('1000000000000000000', Chain.Optimism, Chain.xDai)
     *console.log(amountOut)
     *```
     */
    getAmountOut(tokenAmountIn, sourceChain, destinationChain) {
        return __awaiter(this, void 0, void 0, function* () {
            tokenAmountIn = ethers_1.BigNumber.from(tokenAmountIn.toString());
            sourceChain = this.toChainModel(sourceChain);
            destinationChain = this.toChainModel(destinationChain);
            const hTokenAmount = yield this.calcToHTokenAmount(tokenAmountIn, sourceChain);
            const amountOut = yield this.calcFromHTokenAmount(hTokenAmount, destinationChain);
            return amountOut;
        });
    }
    /**
     * @desc Estimate the bonder liquidity needed at the destination.
     * @param {String} tokenAmountIn - Token amount input.
     * @param {Object} sourceChain - Source chain model.
     * @param {Object} destinationChain - Destination chain model.
     * @returns {Object} Amount as BigNumber.
     * @example
     *```js
     *import { Hop, Chain Token } from '@hop-protocol/sdk'
     *
     *const hop = new Hop()
     *const bridge = hop.connect(signer).bridge(Token.USDC)
     *const requiredLiquidity = await bridge.getRequiredLiquidity('1000000000000000000', Chain.Optimism, Chain.xDai)
     *console.log(requiredLiquidity)
     *```
     */
    getRequiredLiquidity(tokenAmountIn, sourceChain) {
        return __awaiter(this, void 0, void 0, function* () {
            tokenAmountIn = ethers_1.BigNumber.from(tokenAmountIn.toString());
            sourceChain = this.toChainModel(sourceChain);
            if (sourceChain.equals(Chain_1.default.Ethereum)) {
                return ethers_1.BigNumber.from(0);
            }
            const hTokenAmount = yield this.calcToHTokenAmount(tokenAmountIn, sourceChain);
            return hTokenAmount;
        });
    }
    /**
     * @desc Returns the suggested bonder fee.
     * @param {Object} amountIn - Token amount input.
     * @param {Object} sourceChain - Source chain model.
     * @param {Object} destinationChain - Destination chain model.
     * @returns {Object} Bonder fee as BigNumber.
     */
    getMinBonderFee(amountIn, sourceChain, destinationChain) {
        return __awaiter(this, void 0, void 0, function* () {
            sourceChain = this.toChainModel(sourceChain);
            destinationChain = this.toChainModel(destinationChain);
            if (sourceChain.isL1) {
                return ethers_1.BigNumber.from(0);
            }
            const hTokenAmount = yield this.calcToHTokenAmount(amountIn.toString(), sourceChain);
            const feeBps = this.getFeeBps(this.tokenSymbol, destinationChain);
            const token = this.toTokenModel(this.tokenSymbol);
            const tokenPrice = yield this.priceFeed.getPriceByTokenSymbol(token.symbol);
            const minBonderFeeUsd = 0.25;
            const minBonderFeeAbsolute = (0, utils_1.parseUnits)((minBonderFeeUsd / tokenPrice).toFixed(token.decimals), token.decimals);
            const minBonderFeeRelative = hTokenAmount.mul(feeBps).div(10000);
            const minBonderFee = minBonderFeeRelative.gt(minBonderFeeAbsolute)
                ? minBonderFeeRelative
                : minBonderFeeAbsolute;
            return minBonderFee;
        });
    }
    getAvailableLiquidity(chain, bonder = this.getBonderAddress()) {
        return __awaiter(this, void 0, void 0, function* () {
            const [credit, debit] = yield Promise.all([
                this.getCredit(chain, bonder),
                this.getTotalDebit(chain, bonder)
            ]);
            const availableLiquidity = credit.sub(debit);
            return availableLiquidity;
        });
    }
    /**
     * @desc Returns available liquidity for Hop bridge at specified chain.
     * @param {Object} sourceChain - Source chain model.
     * @param {Object} destinationChain - Destination chain model.
     * @returns {Object} Available liquidity as BigNumber.
     */
    getFrontendAvailableLiquidity(sourceChain, destinationChain, bonder = this.getBonderAddress()) {
        return __awaiter(this, void 0, void 0, function* () {
            sourceChain = this.toChainModel(sourceChain);
            destinationChain = this.toChainModel(destinationChain);
            const token = this.toTokenModel(this.tokenSymbol);
            let availableLiquidity = yield this.getAvailableLiquidity(destinationChain, bonder);
            const unbondedTransferRootAmount = yield this.getUnbondedTransferRootAmount(sourceChain, destinationChain);
            if (this.isOruToL1(sourceChain, destinationChain) ||
                this.isNonOruToL1(sourceChain, destinationChain)) {
                const bridgeContract = yield this.getBridgeContract(sourceChain);
                let pendingAmounts = ethers_1.BigNumber.from(0);
                for (const chain of config_1.bondableChains) {
                    const exists = this.getL2BridgeAddress(this.tokenSymbol, chain);
                    if (!exists) {
                        continue;
                    }
                    const bridge = yield this.getBridgeContract(chain);
                    const pendingAmount = yield bridge.pendingAmountForChainId(Chain_1.default.Ethereum.chainId);
                    pendingAmounts = pendingAmounts.add(pendingAmount);
                }
                const tokenPrice = yield this.priceFeed.getPriceByTokenSymbol(token.canonicalSymbol);
                const tokenPriceBn = (0, utils_1.parseUnits)(tokenPrice.toString(), token.decimals);
                const bufferAmountBn = (0, utils_1.parseUnits)(constants_1.PendingAmountBuffer, token.decimals);
                const precision = (0, utils_1.parseUnits)('1', token.decimals);
                const bufferAmountTokensBn = bufferAmountBn
                    .div(tokenPriceBn)
                    .mul(precision);
                availableLiquidity = availableLiquidity
                    .sub(pendingAmounts)
                    .sub(unbondedTransferRootAmount)
                    .sub(bufferAmountTokensBn);
                if (this.isOruToL1(sourceChain, destinationChain)) {
                    availableLiquidity = availableLiquidity.div(2);
                }
            }
            if (availableLiquidity.lt(0)) {
                return ethers_1.BigNumber.from(0);
            }
            return availableLiquidity;
        });
    }
    isOruToL1(sourceChain, destinationChain) {
        return (destinationChain.equals(Chain_1.default.Ethereum) &&
            config_1.bondableChains.includes(sourceChain.slug));
    }
    isNonOruToL1(sourceChain, destinationChain) {
        return (destinationChain.equals(Chain_1.default.Ethereum) &&
            !config_1.bondableChains.includes(sourceChain.slug));
    }
    getBonderAvailableLiquidityData() {
        return __awaiter(this, void 0, void 0, function* () {
            const url = `https://assets.hop.exchange/${this.network}/v1-available-liquidity.json`;
            const res = yield (0, isomorphic_fetch_1.default)(url);
            const json = yield res.json();
            if (!json) {
                throw new Error('expected json object');
            }
            const { timestamp, data } = json;
            const tenMinutes = 10 * 60 * 1000;
            const isOutdated = Date.now() - timestamp > tenMinutes;
            if (isOutdated) {
                return;
            }
            return data;
        });
    }
    getUnbondedTransferRootAmount(sourceChain, destinationChain) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const data = yield this.getBonderAvailableLiquidityData();
                if (data) {
                    const _unbondedTransferRootAmount = (_c = (_b = (_a = data === null || data === void 0 ? void 0 : data[this.tokenSymbol]) === null || _a === void 0 ? void 0 : _a.unbondedTransferRootAmounts) === null || _b === void 0 ? void 0 : _b[sourceChain.slug]) === null || _c === void 0 ? void 0 : _c[destinationChain.slug];
                    if (_unbondedTransferRootAmount) {
                        return ethers_1.BigNumber.from(_unbondedTransferRootAmount);
                    }
                }
            }
            catch (err) {
                console.error(err);
            }
            return ethers_1.BigNumber.from(0);
        });
    }
    /**
     * @desc Returns bridge contract instance for specified chain.
     * @param {Object} chain - chain model.
     * @returns {Object} Ethers contract instance.
     */
    getBridgeContract(chain) {
        return __awaiter(this, void 0, void 0, function* () {
            chain = this.toChainModel(chain);
            let bridge;
            if (chain.isL1) {
                bridge = yield this.getL1Bridge();
            }
            else {
                bridge = yield this.getL2Bridge(chain);
            }
            return bridge;
        });
    }
    /**
     * @desc Returns total credit that bonder holds on Hop bridge at specified chain.
     * @param {Object} chain - Chain model.
     * @returns {Object} Total credit as BigNumber.
     */
    getCredit(chain, bonder = this.getBonderAddress()) {
        return __awaiter(this, void 0, void 0, function* () {
            chain = this.toChainModel(chain);
            const bridge = yield this.getBridgeContract(chain);
            return bridge.getCredit(bonder);
        });
    }
    /**
     * @desc Returns total debit, including sliding window debit, that bonder holds on Hop bridge at specified chain.
     * @param {Object} chain - Chain model.
     * @returns {Object} Total debit as BigNumber.
     */
    getTotalDebit(chain, bonder = this.getBonderAddress()) {
        return __awaiter(this, void 0, void 0, function* () {
            chain = this.toChainModel(chain);
            const bridge = yield this.getBridgeContract(chain);
            return bridge.getDebitAndAdditionalDebit(bonder);
        });
    }
    /**
     * @desc Returns total debit that bonder holds on Hop bridge at specified chain.
     * @param {Object} chain - Chain model.
     * @returns {Object} Total debit as BigNumber.
     */
    getDebit(chain, bonder = this.getBonderAddress()) {
        return __awaiter(this, void 0, void 0, function* () {
            chain = this.toChainModel(chain);
            const bridge = yield this.getBridgeContract(chain);
            return bridge.getRawDebit(bonder);
        });
    }
    /**
     * @desc Sends transaction to execute swap on Saddle contract.
     * @param {Object} sourceChain - Source chain model.
     * @param {Boolean} toHop - Converts to Hop token only if set to true.
     * @param {Object} amount - Amount of token to swap.
     * @param {Object} minAmountOut - Minimum amount of tokens to receive in order
     * for transaction to be successful.
     * @param {Number} deadline - Transaction deadline in seconds.
     * @returns {Object} Ethers transaction object.
     */
    execSaddleSwap(sourceChain, toHop, amount, minAmountOut, deadline) {
        return __awaiter(this, void 0, void 0, function* () {
            sourceChain = this.toChainModel(sourceChain);
            let tokenIndexFrom;
            let tokenIndexTo;
            const l2CanonicalTokenAddress = this.getL2CanonicalTokenAddress(this.tokenSymbol, sourceChain);
            if (!l2CanonicalTokenAddress) {
                throw new Error(`source chain "${sourceChain.slug}" is unsupported`);
            }
            const l2HopBridgeTokenAddress = this.getL2HopBridgeTokenAddress(this.tokenSymbol, sourceChain);
            if (!l2HopBridgeTokenAddress) {
                throw new Error(`source chain "${sourceChain.slug}" is unsupported`);
            }
            const amm = yield this.getAmm(sourceChain);
            const saddleSwap = yield amm.getSaddleSwap();
            const canonicalTokenIndex = Number((yield saddleSwap.getTokenIndex(l2CanonicalTokenAddress)).toString());
            const hopTokenIndex = Number((yield saddleSwap.getTokenIndex(l2HopBridgeTokenAddress)).toString());
            if (toHop) {
                tokenIndexFrom = canonicalTokenIndex;
                tokenIndexTo = hopTokenIndex;
            }
            else {
                tokenIndexFrom = hopTokenIndex;
                tokenIndexTo = canonicalTokenIndex;
            }
            return saddleSwap.swap(tokenIndexFrom, tokenIndexTo, amount, minAmountOut, deadline);
        });
    }
    /**
     * @desc Returns Hop L1 Bridge Ethers contract instance.
     * @param {Object} signer - Ethers signer
     * @returns {Object} Ethers contract instance.
     */
    getL1Bridge(signer = this.signer) {
        return __awaiter(this, void 0, void 0, function* () {
            const bridgeAddress = this.getL1BridgeAddress(this.tokenSymbol, Chain_1.default.Ethereum);
            if (!bridgeAddress) {
                throw new Error(`token "${this.tokenSymbol}" is unsupported`);
            }
            const provider = yield this.getSignerOrProvider(Chain_1.default.Ethereum, signer);
            return this.getContract(bridgeAddress, L1_ERC20_Bridge_json_1.default, provider);
        });
    }
    /**
     * @desc Returns Hop L2 Bridge Ethers contract instance.
     * @param {Object} chain - Chain model.
     * @param {Object} signer - Ethers signer
     * @returns {Object} Ethers contract instance.
     */
    getL2Bridge(chain, signer = this.signer) {
        return __awaiter(this, void 0, void 0, function* () {
            chain = this.toChainModel(chain);
            const bridgeAddress = this.getL2BridgeAddress(this.tokenSymbol, chain);
            if (!bridgeAddress) {
                throw new Error(`token "${this.tokenSymbol}" on chain "${chain.slug}" is unsupported`);
            }
            const provider = yield this.getSignerOrProvider(chain, signer);
            return this.getContract(bridgeAddress, L2_Bridge_json_1.default, provider);
        });
    }
    // ToDo: Docs
    getAmm(chain) {
        chain = this.toChainModel(chain);
        if (chain.isL1) {
            throw new Error('No AMM exists on L1');
        }
        return new AMM_1.default(this.network, this.tokenSymbol, chain, this.signer);
    }
    /**
     * @desc Returns Hop Bridge AMM wrapper Ethers contract instance.
     * @param {Object} chain - Chain model.
     * @param {Object} signer - Ethers signer
     * @returns {Object} Ethers contract instance.
     */
    getAmmWrapper(chain, signer = this.signer) {
        return __awaiter(this, void 0, void 0, function* () {
            chain = this.toChainModel(chain);
            const ammWrapperAddress = this.getL2AmmWrapperAddress(this.tokenSymbol, chain);
            if (!ammWrapperAddress) {
                throw new Error(`token "${this.tokenSymbol}" on chain "${chain.slug}" is unsupported`);
            }
            const provider = yield this.getSignerOrProvider(chain, signer);
            return this.getContract(ammWrapperAddress, L2_AmmWrapper_json_1.default, provider);
        });
    }
    /**
     * @desc Returns Hop Bridge Saddle reserve amounts.
     * @param {Object} chain - Chain model.
     * @returns {Array} Array containing reserve amounts for canonical token
     * and hTokens.
     */
    getSaddleSwapReserves(chain = this.sourceChain) {
        return __awaiter(this, void 0, void 0, function* () {
            const amm = this.getAmm(chain);
            const saddleSwap = yield amm.getSaddleSwap();
            return Promise.all([
                saddleSwap.getTokenBalance(0),
                saddleSwap.getTokenBalance(1)
            ]);
        });
    }
    getReservesTotal(chain = this.sourceChain) {
        return __awaiter(this, void 0, void 0, function* () {
            const [reserve0, reserve1] = yield this.getSaddleSwapReserves(chain);
            return reserve0.add(reserve1);
        });
    }
    /**
     * @desc Returns Hop Bridge Saddle Swap LP Token Ethers contract instance.
     * @param {Object} chain - Chain model.
     * @param {Object} signer - Ethers signer
     * @returns {Object} Ethers contract instance.
     */
    getSaddleLpToken(chain, signer = this.signer) {
        return __awaiter(this, void 0, void 0, function* () {
            // ToDo: Remove ability to pass in signer like other token getters
            chain = this.toChainModel(chain);
            const saddleLpTokenAddress = this.getL2SaddleLpTokenAddress(this.tokenSymbol, chain);
            if (!saddleLpTokenAddress) {
                throw new Error(`token "${this.tokenSymbol}" on chain "${chain.slug}" is unsupported`);
            }
            // ToDo: Get actual saddle LP token symbol and name
            return new Token_1.default(this.network, chain, saddleLpTokenAddress, 18, `${this.tokenSymbol} LP`, `${this.tokenSymbol} LP`, '', signer, this.chainProviders);
        });
    }
    /**
     * @desc Sends transaction to add liquidity to AMM.
     * @param {Object} amount0Desired - Amount of token #0 in smallest unit
     * @param {Object} amount1Desired - Amount of token #1 in smallest unit
     * @param {Object} chain - Chain model of desired chain to add liquidity to.
     * @param {Object} options - Method options.
     * @returns {Object} Ethers transaction object.
     */
    addLiquidity(amount0Desired, amount1Desired, chain, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!chain) {
                chain = this.sourceChain;
            }
            amount0Desired = ethers_1.BigNumber.from(amount0Desired.toString());
            chain = this.toChainModel(chain);
            const amm = new AMM_1.default(this.network, this.tokenSymbol, chain, this.signer, this.chainProviders);
            return amm.addLiquidity(amount0Desired, amount1Desired, options.minToMint, options.deadline);
        });
    }
    /**
     * @desc Sends transaction to remove liquidity from AMM.
     * @param {Object} liquidityTokenAmount - Amount of LP tokens to burn.
     * @param {Object} chain - Chain model of desired chain to add liquidity to.
     * @param {Object} options - Method options.
     * @returns {Object} Ethers transaction object.
     */
    removeLiquidity(liquidityTokenAmount, chain, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!chain) {
                chain = this.sourceChain;
            }
            chain = this.toChainModel(chain);
            const amm = new AMM_1.default(this.network, this.tokenSymbol, chain, this.signer, this.chainProviders);
            return amm.removeLiquidity(liquidityTokenAmount, options.amount0Min, options.amount1Min, options.deadline);
        });
    }
    /**
     * @desc Returns the connected signer address.
     * @returns {String} Ethers signer address
     */
    getSignerAddress() {
        var _a;
        if (!this.signer) {
            throw new Error('signer not connected');
        }
        return (_a = this.signer) === null || _a === void 0 ? void 0 : _a.getAddress();
    }
    /**
     * @readonly
     * @desc The default deadline to use in seconds.
     * @returns {Number} Deadline in seconds
     */
    get defaultDeadlineSeconds() {
        return (Date.now() / 1000 + this.defaultDeadlineMinutes * 60) | 0;
    }
    /**
     * @readonly
     * @desc The time slot for the current time.
     * @param {Object} time - Unix timestamp (in seconds) to get the time slot.
     * @returns {Object} Time slot for the given time as BigNumber.
     */
    getTimeSlot(time) {
        return __awaiter(this, void 0, void 0, function* () {
            const bridge = yield this.getL1Bridge();
            time = ethers_1.BigNumber.from(time.toString());
            return bridge.getTimeSlot(time);
        });
    }
    /**
     * @readonly
     * @desc The challenge period.
     * @returns {Object} The challenge period for the bridge as BigNumber.
     */
    challengePeriod() {
        return __awaiter(this, void 0, void 0, function* () {
            const bridge = yield this.getL1Bridge();
            return bridge.challengePeriod();
        });
    }
    /**
     * @readonly
     * @desc The size of the time slots.
     * @returns {Object} The size of the time slots for the bridge as BigNumber.
     */
    timeSlotSize() {
        return __awaiter(this, void 0, void 0, function* () {
            const bridge = yield this.getL1Bridge();
            return bridge.TIME_SLOT_SIZE();
        });
    }
    /**
     * @readonly
     * @desc The amount bonded for a time slot for a bonder.
     * @param {Object} chain - Chain model.
     * @param {Number} timeSlot - Time slot to get.
     * @param {String} bonder - Address of the bonder to check.
     * @returns {Object} Amount bonded for the bonder for the given time slot as BigNumber.
     */
    timeSlotToAmountBonded(timeSlot, bonder = this.getBonderAddress()) {
        return __awaiter(this, void 0, void 0, function* () {
            const bridge = yield this.getL1Bridge();
            timeSlot = ethers_1.BigNumber.from(timeSlot.toString());
            return bridge.timeSlotToAmountBonded(timeSlot, bonder);
        });
    }
    getTokenIndexes(path, chain) {
        return __awaiter(this, void 0, void 0, function* () {
            const amm = this.getAmm(chain);
            const saddleSwap = yield amm.getSaddleSwap();
            const tokenIndexFrom = Number((yield saddleSwap.getTokenIndex(path[0])).toString());
            const tokenIndexTo = Number((yield saddleSwap.getTokenIndex(path[1])).toString());
            return [tokenIndexFrom, tokenIndexTo];
        });
    }
    sendHandler(tokenAmount, sourceChain, destinationChain, approval = false, options = {}) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            tokenAmount = ethers_1.BigNumber.from(tokenAmount.toString());
            sourceChain = this.toChainModel(sourceChain);
            destinationChain = this.toChainModel(destinationChain);
            const estimateGasOnly = options === null || options === void 0 ? void 0 : options.estimateGasOnly;
            if (!estimateGasOnly) {
                let balance;
                const canonicalToken = this.getCanonicalToken(sourceChain);
                if (this.isNativeToken(sourceChain)) {
                    balance = yield canonicalToken.getNativeTokenBalance();
                }
                else {
                    balance = yield canonicalToken.balanceOf();
                }
                if (balance.lt(tokenAmount)) {
                    throw new Error('not enough token balance');
                }
            }
            // L1 -> L1 or L2
            if (sourceChain.isL1) {
                // L1 -> L1
                if (destinationChain.isL1) {
                    throw new Error('Cannot send from layer 1 to layer 1');
                }
                // L1 -> L2
                return this.sendL1ToL2({
                    destinationChainId: destinationChain.chainId,
                    sourceChain,
                    relayer: (_a = options === null || options === void 0 ? void 0 : options.relayer) !== null && _a !== void 0 ? _a : ethers_1.ethers.constants.AddressZero,
                    relayerFee: (_b = options === null || options === void 0 ? void 0 : options.relayerFee) !== null && _b !== void 0 ? _b : 0,
                    amount: tokenAmount,
                    amountOutMin: (_c = options === null || options === void 0 ? void 0 : options.amountOutMin) !== null && _c !== void 0 ? _c : 0,
                    deadline: options === null || options === void 0 ? void 0 : options.deadline,
                    recipient: options === null || options === void 0 ? void 0 : options.recipient,
                    approval,
                    estimateGasOnly
                });
            }
            // else:
            // L2 -> L1 or L2
            // L2 -> L1
            if (destinationChain.isL1) {
                let bonderFee = options === null || options === void 0 ? void 0 : options.bonderFee;
                if (!bonderFee) {
                    bonderFee = yield this.getTotalFee(tokenAmount, sourceChain, destinationChain, options === null || options === void 0 ? void 0 : options.destinationDeadline);
                }
                return this.sendL2ToL1({
                    destinationChainId: destinationChain.chainId,
                    sourceChain,
                    amount: tokenAmount,
                    bonderFee,
                    recipient: options === null || options === void 0 ? void 0 : options.recipient,
                    amountOutMin: options === null || options === void 0 ? void 0 : options.amountOutMin,
                    deadline: options === null || options === void 0 ? void 0 : options.deadline,
                    destinationAmountOutMin: options === null || options === void 0 ? void 0 : options.destinationAmountOutMin,
                    destinationDeadline: options === null || options === void 0 ? void 0 : options.destinationDeadline,
                    approval,
                    estimateGasOnly
                });
            }
            // L2 -> L2
            let bonderFee = options === null || options === void 0 ? void 0 : options.bonderFee;
            if (!bonderFee) {
                bonderFee = yield this.getTotalFee(tokenAmount, sourceChain, destinationChain, options === null || options === void 0 ? void 0 : options.destinationDeadline);
            }
            return this.sendL2ToL2({
                destinationChainId: destinationChain.chainId,
                sourceChain,
                amount: tokenAmount,
                bonderFee,
                recipient: options === null || options === void 0 ? void 0 : options.recipient,
                amountOutMin: options === null || options === void 0 ? void 0 : options.amountOutMin,
                deadline: options === null || options === void 0 ? void 0 : options.deadline,
                destinationAmountOutMin: options === null || options === void 0 ? void 0 : options.destinationAmountOutMin,
                destinationDeadline: options === null || options === void 0 ? void 0 : options.destinationDeadline,
                approval,
                estimateGasOnly
            });
        });
    }
    sendL1ToL2(input) {
        return __awaiter(this, void 0, void 0, function* () {
            let { destinationChainId, sourceChain, relayer, relayerFee, amount, amountOutMin, deadline, recipient, approval, estimateGasOnly } = input;
            if (!sourceChain.isL1) {
                // ToDo: Don't pass in sourceChain since it will always be L1
                throw new Error('sourceChain must be L1 when calling sendL1ToL2');
            }
            deadline = deadline === undefined ? this.defaultDeadlineSeconds : deadline;
            recipient = (0, utils_1.getAddress)(recipient || (yield this.getSignerAddress()));
            this.checkConnectedChain(this.signer, sourceChain);
            amountOutMin = ethers_1.BigNumber.from((amountOutMin || 0).toString());
            const l1Bridge = yield this.getL1Bridge(this.signer);
            const isNativeToken = this.isNativeToken(sourceChain);
            if (!estimateGasOnly) {
                if (!isNativeToken) {
                    const l1Token = this.getL1Token();
                    if (approval) {
                        const tx = yield l1Token.approve(l1Bridge.address, amount);
                        yield (tx === null || tx === void 0 ? void 0 : tx.wait());
                    }
                    else {
                        const allowance = yield l1Token.allowance(l1Bridge.address);
                        if (allowance.lt(ethers_1.BigNumber.from(amount))) {
                            throw new Error('not enough allowance');
                        }
                    }
                }
            }
            if (amountOutMin.lt(0)) {
                amountOutMin = ethers_1.BigNumber.from(0);
            }
            const txOptions = [
                destinationChainId,
                recipient,
                amount || 0,
                amountOutMin,
                deadline,
                relayer,
                relayerFee || 0,
                Object.assign(Object.assign({}, (yield this.txOverrides(Chain_1.default.Ethereum))), { value: isNativeToken ? amount : undefined })
            ];
            if (estimateGasOnly) {
                return l1Bridge.estimateGas.sendToL2(...txOptions);
            }
            return l1Bridge.sendToL2(...txOptions);
        });
    }
    sendL2ToL1(input) {
        return __awaiter(this, void 0, void 0, function* () {
            let { destinationChainId, sourceChain, amount, destinationAmountOutMin, bonderFee, recipient, amountOutMin, deadline, destinationDeadline, approval, estimateGasOnly } = input;
            deadline = deadline === undefined ? this.defaultDeadlineSeconds : deadline;
            destinationDeadline = destinationDeadline || 0;
            amountOutMin = ethers_1.BigNumber.from((amountOutMin || 0).toString());
            destinationAmountOutMin = ethers_1.BigNumber.from((destinationAmountOutMin || 0).toString());
            recipient = (0, utils_1.getAddress)(recipient || (yield this.getSignerAddress()));
            this.checkConnectedChain(this.signer, sourceChain);
            const ammWrapper = yield this.getAmmWrapper(sourceChain, this.signer);
            const l2Bridge = yield this.getL2Bridge(sourceChain, this.signer);
            const attemptSwap = deadline || destinationDeadline;
            const spender = attemptSwap ? ammWrapper.address : l2Bridge.address;
            if (ethers_1.BigNumber.from(bonderFee).gt(amount)) {
                throw new Error('amount must be greater than bonder fee');
            }
            const isNativeToken = this.isNativeToken(sourceChain);
            if (!estimateGasOnly) {
                if (!isNativeToken) {
                    const l2CanonicalToken = this.getCanonicalToken(sourceChain);
                    if (approval) {
                        const tx = yield l2CanonicalToken.approve(spender, amount);
                        yield (tx === null || tx === void 0 ? void 0 : tx.wait());
                    }
                    else {
                        const allowance = yield l2CanonicalToken.allowance(spender);
                        if (allowance.lt(ethers_1.BigNumber.from(amount))) {
                            throw new Error('not enough allowance');
                        }
                    }
                }
            }
            if (amountOutMin.lt(0)) {
                amountOutMin = ethers_1.BigNumber.from(0);
            }
            if (destinationAmountOutMin.lt(0)) {
                destinationAmountOutMin = ethers_1.BigNumber.from(0);
            }
            const txOptions = [
                destinationChainId,
                recipient,
                amount,
                bonderFee,
                amountOutMin,
                deadline
            ];
            if (attemptSwap) {
                const additionalOptions = [
                    destinationAmountOutMin,
                    destinationDeadline,
                    Object.assign(Object.assign({}, (yield this.txOverrides(sourceChain))), { value: isNativeToken ? amount : undefined })
                ];
                if (estimateGasOnly) {
                    return ammWrapper.estimateGas.swapAndSend(...txOptions, ...additionalOptions);
                }
                return ammWrapper.swapAndSend(...txOptions, ...additionalOptions);
            }
            return l2Bridge.send(...txOptions, Object.assign(Object.assign({}, (yield this.txOverrides(sourceChain))), { value: isNativeToken ? amount : undefined }));
        });
    }
    sendL2ToL2(input) {
        return __awaiter(this, void 0, void 0, function* () {
            let { destinationChainId, sourceChain, amount, destinationAmountOutMin, bonderFee, deadline, destinationDeadline, amountOutMin, recipient, approval, estimateGasOnly } = input;
            deadline = deadline || this.defaultDeadlineSeconds;
            destinationDeadline = destinationDeadline || deadline;
            amountOutMin = ethers_1.BigNumber.from((amountOutMin || 0).toString());
            destinationAmountOutMin = ethers_1.BigNumber.from((destinationAmountOutMin || 0).toString());
            recipient = (0, utils_1.getAddress)(recipient || (yield this.getSignerAddress()));
            if (ethers_1.BigNumber.from(bonderFee).gt(amount)) {
                throw new Error('Amount must be greater than bonder fee');
            }
            this.checkConnectedChain(this.signer, sourceChain);
            const ammWrapper = yield this.getAmmWrapper(sourceChain, this.signer);
            const isNativeToken = this.isNativeToken(sourceChain);
            if (!estimateGasOnly) {
                if (!isNativeToken) {
                    const l2CanonicalToken = this.getCanonicalToken(sourceChain);
                    if (approval) {
                        const tx = yield l2CanonicalToken.approve(ammWrapper.address, amount);
                        yield (tx === null || tx === void 0 ? void 0 : tx.wait());
                    }
                    else {
                        const allowance = yield l2CanonicalToken.allowance(ammWrapper.address);
                        if (allowance.lt(ethers_1.BigNumber.from(amount))) {
                            throw new Error('not enough allowance');
                        }
                    }
                }
            }
            if (amountOutMin.lt(0)) {
                amountOutMin = ethers_1.BigNumber.from(0);
            }
            if (destinationAmountOutMin.lt(0)) {
                destinationAmountOutMin = ethers_1.BigNumber.from(0);
            }
            const txOptions = [
                destinationChainId,
                recipient,
                amount,
                bonderFee,
                amountOutMin,
                deadline,
                destinationAmountOutMin,
                destinationDeadline,
                Object.assign(Object.assign({}, (yield this.txOverrides(sourceChain))), { value: isNativeToken ? amount : undefined })
            ];
            if (estimateGasOnly) {
                return ammWrapper.estimateGas.swapAndSend(...txOptions);
            }
            return ammWrapper.swapAndSend(...txOptions);
        });
    }
    sendHTokenHandler(tokenAmount, sourceChain, destinationChain, options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            sourceChain = this.toChainModel(sourceChain);
            destinationChain = this.toChainModel(destinationChain);
            if (sourceChain.isL1 && destinationChain.isL1) {
                throw new Error('sourceChain and destinationChain cannot both be L1');
            }
            else if (!sourceChain.isL1 && !destinationChain.isL1) {
                throw new Error('Sending hToken L2 to L2 is not currently supported');
            }
            if ((options === null || options === void 0 ? void 0 : options.deadline) ||
                (options === null || options === void 0 ? void 0 : options.amountOutMin) ||
                (options === null || options === void 0 ? void 0 : options.destinationDeadline) ||
                (options === null || options === void 0 ? void 0 : options.destinationAmountOutMin)) {
                throw new Error('Invalid sendHTokenHandler option');
            }
            let minBonderFee = ethers_1.BigNumber.from(0);
            if (!sourceChain.isL1) {
                minBonderFee = yield this.getBonderFee(tokenAmount, sourceChain, destinationChain);
            }
            const recipient = (0, utils_1.getAddress)((_a = options === null || options === void 0 ? void 0 : options.recipient) !== null && _a !== void 0 ? _a : (yield this.getSignerAddress()));
            const bonderFee = (options === null || options === void 0 ? void 0 : options.bonderFee)
                ? ethers_1.BigNumber.from(options === null || options === void 0 ? void 0 : options.bonderFee)
                : minBonderFee;
            const amountOutMin = ethers_1.BigNumber.from(0);
            const deadline = ethers_1.BigNumber.from(0);
            const relayer = ethers_1.ethers.constants.AddressZero;
            if (sourceChain.isL1) {
                if (bonderFee.gt(0)) {
                    throw new Error('Bonder fee should be 0 when sending hToken to L2');
                }
                const l1Bridge = yield this.getL1Bridge(this.signer);
                const isNativeToken = this.isNativeToken(sourceChain);
                const txOptions = [
                    destinationChain.chainId,
                    recipient,
                    tokenAmount,
                    amountOutMin,
                    deadline,
                    relayer,
                    bonderFee,
                    Object.assign(Object.assign({}, (yield this.txOverrides(Chain_1.default.Ethereum))), { value: isNativeToken ? tokenAmount : undefined })
                ];
                if (options.estimateGasOnly) {
                    return l1Bridge.estimateGas.sendToL2(...txOptions);
                }
                return l1Bridge.sendToL2(...txOptions);
            }
            else {
                if (bonderFee.eq(0)) {
                    throw new Error('Send at least the minimum Bonder fee');
                }
                const l2Bridge = yield this.getL2Bridge(sourceChain, this.signer);
                const txOptions = [
                    destinationChain.chainId,
                    recipient,
                    tokenAmount,
                    bonderFee,
                    amountOutMin,
                    deadline,
                    yield this.txOverrides(sourceChain)
                ];
                if (options.estimateGasOnly) {
                    return l2Bridge.estimateGas.send(...txOptions);
                }
                return l2Bridge.send(...txOptions);
            }
        });
    }
    calcToHTokenAmount(amount, chain) {
        return __awaiter(this, void 0, void 0, function* () {
            amount = ethers_1.BigNumber.from(amount.toString());
            if (chain.isL1) {
                return amount;
            }
            const amm = this.getAmm(chain);
            const saddleSwap = yield amm.getSaddleSwap();
            if (amount.eq(0)) {
                return ethers_1.BigNumber.from(0);
            }
            const amountOut = yield saddleSwap.calculateSwap(constants_1.TokenIndex.CanonicalToken, constants_1.TokenIndex.HopBridgeToken, amount);
            return amountOut;
        });
    }
    calcFromHTokenAmount(amount, chain) {
        return __awaiter(this, void 0, void 0, function* () {
            amount = ethers_1.BigNumber.from(amount.toString());
            if (chain.isL1) {
                return ethers_1.BigNumber.from(amount);
            }
            const amm = this.getAmm(chain);
            const saddleSwap = yield amm.getSaddleSwap();
            if (amount.eq(0)) {
                return ethers_1.BigNumber.from(0);
            }
            const amountOut = yield saddleSwap.calculateSwap(constants_1.TokenIndex.HopBridgeToken, constants_1.TokenIndex.CanonicalToken, amount);
            return amountOut;
        });
    }
    getRate(amountIn, amountOut, sourceToken, destToken) {
        let rateBN;
        if (amountIn.eq(0)) {
            rateBN = ethers_1.BigNumber.from(0);
        }
        else {
            const oneSourceBN = ethers_1.ethers.utils.parseUnits('1', sourceToken.decimals);
            rateBN = amountOut.mul(oneSourceBN).div(amountIn);
        }
        const rate = Number(ethers_1.ethers.utils.formatUnits(rateBN, destToken.decimals));
        return rate;
    }
    getPriceImpact(rate, marketRate) {
        return ((marketRate - rate) / marketRate) * 100;
    }
    checkConnectedChain(signer, chain) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const connectedChainId = yield ((_a = signer) === null || _a === void 0 ? void 0 : _a.getChainId());
            if (connectedChainId !== chain.chainId) {
                throw new Error('invalid connected chain ID. Make sure signer provider is connected to source chain network');
            }
        });
    }
    // xDai AMB bridge
    getAmbBridge(chain) {
        return __awaiter(this, void 0, void 0, function* () {
            chain = this.toChainModel(chain);
            if (chain.equals(Chain_1.default.Ethereum)) {
                const address = this.getL1AmbBridgeAddress(this.tokenSymbol, Chain_1.default.xDai);
                const provider = yield this.getSignerOrProvider(Chain_1.default.Ethereum);
                return this.getContract(address, L1_HomeAMBNativeToErc20_json_1.default, provider);
            }
            const address = this.getL2AmbBridgeAddress(this.tokenSymbol, Chain_1.default.xDai);
            const provider = yield this.getSignerOrProvider(Chain_1.default.xDai);
            return this.getContract(address, L1_HomeAMBNativeToErc20_json_1.default, provider);
        });
    }
    getChainNativeToken(chain) {
        chain = this.toChainModel(chain);
        if (chain === null || chain === void 0 ? void 0 : chain.equals(Chain_1.default.Polygon)) {
            return this.toTokenModel('MATIC');
        }
        else if (chain === null || chain === void 0 ? void 0 : chain.equals(Chain_1.default.xDai)) {
            return this.toTokenModel('DAI');
        }
        return this.toTokenModel('ETH');
    }
    isNativeToken(chain) {
        const token = this.getCanonicalToken(chain || this.sourceChain);
        return token.isNativeToken;
    }
    getEthBalance(chain = this.sourceChain, address) {
        return __awaiter(this, void 0, void 0, function* () {
            chain = this.toChainModel(chain);
            const _address = address !== null && address !== void 0 ? address : (yield this.getSignerAddress());
            return chain.provider.getBalance(_address);
        });
    }
    isSupportedAsset(chain) {
        var _a;
        chain = this.toChainModel(chain);
        const supported = this.getSupportedAssets();
        return !!((_a = supported[chain.slug]) === null || _a === void 0 ? void 0 : _a[this.tokenSymbol]);
    }
    getBonderAddress() {
        return super.getBonderAddress(this.tokenSymbol);
    }
    shouldAttemptSwap(amountOutMin, deadline) {
        deadline = ethers_1.BigNumber.from((deadline === null || deadline === void 0 ? void 0 : deadline.toString()) || 0);
        return (amountOutMin === null || amountOutMin === void 0 ? void 0 : amountOutMin.gt(0)) || (deadline === null || deadline === void 0 ? void 0 : deadline.gt(0));
    }
}
exports.default = HopBridge;
