import Base, { ChainProviders } from './Base';
import TokenClass from './Token';
import { Chain } from './models';
import { Contract, ethers } from 'ethers';
import { TAmount, TChain, TProvider, TToken } from './types';
/**
 * Class reprensenting Canonical Token Bridge.
 * @namespace CanonicalBridge
 */
declare class CanonicalBridge extends Base {
    /** Chain model */
    chain: Chain;
    /** Token class instance */
    tokenSymbol: string;
    /**
     * @desc Instantiates Canonical Token Bridge.
     * Returns a new Canonical Token Bridge instance.
     * @param {String} network - L1 network name (e.g. 'mainnet', 'kovan', 'goerli')
     * @param {Object} signer - Ethers `Signer` for signing transactions.
     * @param {Object} token - Token symbol or model
     * @param {Object} chain - Chain model
     * @returns {Object} CanonicalBridge SDK instance.
     * @example
     *```js
     *import { CanonicalHop, Chain, Token } from '@hop-protocol/sdk'
     *import { Wallet } from 'ethers'
     *
     *const signer = new Wallet(privateKey)
     *const bridge = new CanonicalBridge('kovan', signer, Token.USDC, Chain.Optimism)
     *```
     */
    constructor(network: string, signer: TProvider, token: TToken, chain: TChain, chainProviders?: ChainProviders);
    /**
     * @desc Return address of L1 canonical token bridge.
     * @return {String} L1 canonical token bridge address
     */
    get address(): any;
    /**
     * @desc Returns canonical bridge instance with signer connected. Used for adding or changing signer.
     * @param {Object} signer - Ethers `Signer` for signing transactions.
     * @returns {Object} New CanonicalBridge SDK instance with connected signer.
     */
    connect(signer: TProvider): CanonicalBridge;
    getDepositApprovalAddress(chain?: TChain): string;
    /**
     * @desc Sends transaction to approve tokens for canonical token bridge deposit.
     * Will only send approval transaction if necessary.
     * @param {Object} amount - Token amount to approve.
     * @param {Object} chain - Chain model.
     * @returns {Object} Ethers transaction object.
     */
    approveDeposit(amount: TAmount, chain?: TChain): Promise<any>;
    /**
     * @desc Sends transaction to canonical token bridge to deposit tokens into L2.
     * @param {Object} amount - Token amount to deposit.
     * @param {Object} chain - Chain model.
     * @returns {Object} Ethers transaction object.
     */
    deposit(amount: TAmount, chain?: TChain): Promise<any>;
    getWithdrawApprovalAddress(chain?: TChain): string;
    /**
     * @desc Sends transaction to approve tokens for canonical token bridge withdrawal.
     * Will only send approval transaction if necessary.
     * @param {Object} amount - Token amount to approve.
     * @returns {Object} Ethers transaction object.
     */
    approveWithdraw(amount: TAmount): Promise<any>;
    /**
     * @desc Sends transaction to L2 canonical token bridge to withdraw tokens into L1.
     * @param {Object} amount - Token amount to withdraw.
     * @param {Object} chain - Chain model.
     * @returns {Object} Ethers transaction object.
     */
    withdraw(amount: TAmount, chain?: TChain): Promise<any>;
    /**
     * @desc Sends transaction to finalize withdrawal.
     * This call is necessary on Polygon to finalize L2 withdrawal into L1 on
     * certain chains. Will only send transaction if necessary.
     * @param {String} txHash - Transaction hash proving token burn on L2.
     * @param {Object} chain - Chain model.
     * @returns {Object} Ethers transaction object.
     */
    exit(txHash: string, chain: TChain): Promise<ethers.providers.TransactionResponse>;
    /**
     * @desc Checks if the amount of tokens is allowed by the canonical token bridge,
     * otherwise throw an error.
     * @param {Object} chain - Chain model.
     * @param {Object} canonicalBridge - Ethers contract object for canonical token bridge.
     * @param {Object} amount - Token amount.
     */
    private checkMaxTokensAllowed;
    getAmbBridge(chain?: TChain): Promise<Contract>;
    getL2CanonicalBridge(): Promise<Contract>;
    getL1CanonicalBridge(): Promise<Contract>;
    getL1Token(): TokenClass;
    getCanonicalToken(chain: TChain): TokenClass;
    getL2HopToken(chain: TChain): TokenClass;
    toCanonicalToken(token: TToken, network: string, chain: TChain): TokenClass;
    toHopToken(token: TToken, network: string, chain: TChain): TokenClass;
}
export default CanonicalBridge;
//# sourceMappingURL=CanonicalBridge.d.ts.map