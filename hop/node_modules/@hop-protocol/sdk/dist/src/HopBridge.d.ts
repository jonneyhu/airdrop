import AMM from './AMM';
import Base, { ChainProviders } from './Base';
import Chain from './models/Chain';
import Token from './Token';
import TokenModel from './models/Token';
import { BigNumber, BigNumberish, Signer, ethers } from 'ethers';
import { PriceFeed } from './priceFeed';
import { TAmount, TChain, TProvider, TTime, TTimeSlot, TToken } from './types';
declare type SendOptions = {
    deadline: BigNumberish;
    relayer: string;
    relayerFee: TAmount;
    recipient: string;
    amountOutMin: TAmount;
    bonderFee: TAmount;
    destinationAmountOutMin: TAmount;
    destinationDeadline: BigNumberish;
    estimateGasOnly?: boolean;
    estimateGasCostOnly?: boolean;
};
declare type AddLiquidityOptions = {
    minToMint: TAmount;
    deadline: BigNumberish;
};
declare type RemoveLiquidityOptions = {
    amount0Min: TAmount;
    amount1Min: TAmount;
    deadline: BigNumberish;
};
/**
 * Class reprensenting Hop bridge.
 * @namespace HopBridge
 */
declare class HopBridge extends Base {
    private tokenSymbol;
    /** Source Chain model */
    sourceChain: Chain;
    /** Destination Chain model */
    destinationChain: Chain;
    /** Default deadline for transfers */
    defaultDeadlineMinutes: number;
    readonly priceFeed: PriceFeed;
    /**
     * @desc Instantiates Hop Bridge.
     * Returns a new Hop Bridge instance.
     * @param {String} network - L1 network name (e.g. 'mainnet', 'kovan', 'goerli')
     * @param {Object} signer - Ethers `Signer` for signing transactions.
     * @param {Object} token - Token symbol or model
     * @param {Object} sourceChain - Source chain model
     * @param {Object} destinationChain - Destination chain model
     * @returns {Object} HopBridge SDK instance.
     * @example
     *```js
     *import { HopBridge, Chain, Token } from '@hop-protocol/sdk'
     *import { Wallet } from 'ethers'
     *
     *const signer = new Wallet(privateKey)
     *const bridge = new HopBridge('kovan', signer, Token.USDC, Chain.Optimism, Chain.xDai)
     *```
     */
    constructor(network: string, signer: TProvider, token: TToken, chainProviders?: ChainProviders);
    /**
     * @desc Returns hop bridge instance with signer connected. Used for adding or changing signer.
     * @param {Object} signer - Ethers `Signer` for signing transactions.
     * @returns {Object} New HopBridge SDK instance with connected signer.
     * @example
     *```js
     *import { Hop, Token } from '@hop-protocol/sdk'
     *import { Wallet } from 'ethers'
     *
     *const signer = new Wallet(privateKey)
     *let hop = new Hop()
     * // ...
     *const bridge = hop.bridge(Token.USDC).connect(signer)
     *```
     */
    connect(signer: Signer): HopBridge;
    getL1Token(): Token;
    getCanonicalToken(chain: TChain): Token;
    getL2HopToken(chain: TChain): Token;
    toCanonicalToken(token: TToken, network: string, chain: TChain): Token | undefined;
    toHopToken(token: TToken, network: string, chain: TChain): Token | undefined;
    /**
     * @desc Approve and send tokens to another chain. This will make an approval
     * transaction if not enough allowance.
     * @param {String} tokenAmount - Token amount to send denominated in smallest unit.
     * @param {Object} sourceChain - Source chain model.
     * @param {Object} destinationChain - Destination chain model.
     * @returns {Object} Ethers Transaction object.
     * @example
     *```js
     *import { Hop, Token } from '@hop-protocol/sdk'
     *
     *const hop = new Hop()
     *const bridge = hop.connect(signer).bridge(Token.USDC)
     *\// send 1 USDC token from Optimism -> xDai
     *const tx = await bridge.send('1000000000000000000', Chain.Optimism, Chain.xDai)
     *console.log(tx.hash)
     *```
     */
    approveAndSend(tokenAmount: TAmount, sourceChain?: TChain, destinationChain?: TChain, options?: Partial<SendOptions>): Promise<any>;
    /**
     * @desc Send tokens to another chain.
     * @param {String} tokenAmount - Token amount to send denominated in smallest unit.
     * @param {Object} sourceChain - Source chain model.
     * @param {Object} destinationChain - Destination chain model.
     * @returns {Object} Ethers Transaction object.
     * @example
     *```js
     *import { Hop, Chain, Token } from '@hop-protocol/sdk'
     *
     *const hop = new Hop()
     *const bridge = hop.connect(signer).bridge(Token.USDC)
     *\// send 1 USDC token from Optimism -> xDai
     *const tx = await bridge.send('1000000000000000000', Chain.Optimism, Chain.xDai)
     *console.log(tx.hash)
     *```
     */
    send(tokenAmount: TAmount, sourceChain?: TChain, destinationChain?: TChain, options?: Partial<SendOptions>): Promise<any>;
    getSendEstimatedGasLimit(tokenAmount: TAmount, sourceChain?: TChain, destinationChain?: TChain, options?: Partial<SendOptions>): Promise<any>;
    getSendEstimatedGasCost(tokenAmount: TAmount, sourceChain?: TChain, destinationChain?: TChain, options?: Partial<SendOptions>): Promise<any>;
    getSendApprovalAddress(sourceChain: TChain, destinationChain: TChain, isHTokenTransfer?: boolean): any;
    sendHToken(tokenAmount: TAmount, sourceChain: TChain, destinationChain: TChain, options?: Partial<SendOptions>): Promise<any>;
    getTokenSymbol(): string;
    getTokenImage(): string;
    getSendData(amountIn: BigNumberish, sourceChain?: TChain, destinationChain?: TChain, deadline?: BigNumberish): Promise<{
        amountOut: BigNumber;
        rate: number;
        priceImpact: number;
        requiredLiquidity: BigNumber;
        lpFees: BigNumber;
        adjustedBonderFee: BigNumber;
        adjustedDestinationTxFee: BigNumber;
        totalFee: BigNumber;
        estimatedReceived: BigNumber;
    }>;
    getAmmData(chain: TChain, amountIn: BigNumberish, isToHToken: boolean, slippageTolerance: number): Promise<{
        rate: number;
        priceImpact: number;
        amountOutMin: BigNumber;
        lpFeeAmount: BigNumber;
    }>;
    getBonderFee(amountIn: BigNumberish, sourceChain: TChain, destinationChain: TChain): Promise<BigNumber>;
    getTotalFee(amountIn: BigNumberish, sourceChain: TChain, destinationChain: TChain, deadline?: BigNumberish): Promise<BigNumber>;
    getLpFees(amountIn: BigNumberish, sourceChain: TChain, destinationChain: TChain): Promise<BigNumber>;
    getDestinationTransactionFee(sourceChain: TChain, destinationChain: TChain): Promise<BigNumber>;
    getOptimismL1Fee(): Promise<any>;
    private getBondWithdrawalEstimatedGas;
    /**
     * @desc Estimate token amount out.
     * @param {String} tokenAmountIn - Token amount input.
     * @param {Object} sourceChain - Source chain model.
     * @param {Object} destinationChain - Destination chain model.
     * @returns {Object} Amount as BigNumber.
     * @example
     *```js
     *import { Hop, Chain Token } from '@hop-protocol/sdk'
     *
     *const hop = new Hop()
     *const bridge = hop.connect(signer).bridge(Token.USDC)
     *const amountOut = await bridge.getAmountOut('1000000000000000000', Chain.Optimism, Chain.xDai)
     *console.log(amountOut)
     *```
     */
    getAmountOut(tokenAmountIn: TAmount, sourceChain?: TChain, destinationChain?: TChain): Promise<BigNumber>;
    /**
     * @desc Estimate the bonder liquidity needed at the destination.
     * @param {String} tokenAmountIn - Token amount input.
     * @param {Object} sourceChain - Source chain model.
     * @param {Object} destinationChain - Destination chain model.
     * @returns {Object} Amount as BigNumber.
     * @example
     *```js
     *import { Hop, Chain Token } from '@hop-protocol/sdk'
     *
     *const hop = new Hop()
     *const bridge = hop.connect(signer).bridge(Token.USDC)
     *const requiredLiquidity = await bridge.getRequiredLiquidity('1000000000000000000', Chain.Optimism, Chain.xDai)
     *console.log(requiredLiquidity)
     *```
     */
    getRequiredLiquidity(tokenAmountIn: TAmount, sourceChain: TChain): Promise<BigNumber>;
    /**
     * @desc Returns the suggested bonder fee.
     * @param {Object} amountIn - Token amount input.
     * @param {Object} sourceChain - Source chain model.
     * @param {Object} destinationChain - Destination chain model.
     * @returns {Object} Bonder fee as BigNumber.
     */
    getMinBonderFee(amountIn: TAmount, sourceChain: TChain, destinationChain: TChain): Promise<BigNumber>;
    getAvailableLiquidity(chain: TChain, bonder?: string): Promise<BigNumber>;
    /**
     * @desc Returns available liquidity for Hop bridge at specified chain.
     * @param {Object} sourceChain - Source chain model.
     * @param {Object} destinationChain - Destination chain model.
     * @returns {Object} Available liquidity as BigNumber.
     */
    getFrontendAvailableLiquidity(sourceChain: TChain, destinationChain: TChain, bonder?: string): Promise<BigNumber>;
    isOruToL1(sourceChain: Chain, destinationChain: Chain): boolean;
    isNonOruToL1(sourceChain: Chain, destinationChain: Chain): boolean;
    getBonderAvailableLiquidityData(): Promise<any>;
    getUnbondedTransferRootAmount(sourceChain: Chain, destinationChain: Chain): Promise<BigNumber>;
    /**
     * @desc Returns bridge contract instance for specified chain.
     * @param {Object} chain - chain model.
     * @returns {Object} Ethers contract instance.
     */
    getBridgeContract(chain: TChain): Promise<ethers.Contract>;
    /**
     * @desc Returns total credit that bonder holds on Hop bridge at specified chain.
     * @param {Object} chain - Chain model.
     * @returns {Object} Total credit as BigNumber.
     */
    getCredit(chain: TChain, bonder?: string): Promise<BigNumber>;
    /**
     * @desc Returns total debit, including sliding window debit, that bonder holds on Hop bridge at specified chain.
     * @param {Object} chain - Chain model.
     * @returns {Object} Total debit as BigNumber.
     */
    getTotalDebit(chain: TChain, bonder?: string): Promise<BigNumber>;
    /**
     * @desc Returns total debit that bonder holds on Hop bridge at specified chain.
     * @param {Object} chain - Chain model.
     * @returns {Object} Total debit as BigNumber.
     */
    getDebit(chain: TChain, bonder?: string): Promise<BigNumber>;
    /**
     * @desc Sends transaction to execute swap on Saddle contract.
     * @param {Object} sourceChain - Source chain model.
     * @param {Boolean} toHop - Converts to Hop token only if set to true.
     * @param {Object} amount - Amount of token to swap.
     * @param {Object} minAmountOut - Minimum amount of tokens to receive in order
     * for transaction to be successful.
     * @param {Number} deadline - Transaction deadline in seconds.
     * @returns {Object} Ethers transaction object.
     */
    execSaddleSwap(sourceChain: TChain, toHop: boolean, amount: TAmount, minAmountOut: TAmount, deadline: BigNumberish): Promise<any>;
    /**
     * @desc Returns Hop L1 Bridge Ethers contract instance.
     * @param {Object} signer - Ethers signer
     * @returns {Object} Ethers contract instance.
     */
    getL1Bridge(signer?: TProvider): Promise<ethers.Contract>;
    /**
     * @desc Returns Hop L2 Bridge Ethers contract instance.
     * @param {Object} chain - Chain model.
     * @param {Object} signer - Ethers signer
     * @returns {Object} Ethers contract instance.
     */
    getL2Bridge(chain: TChain, signer?: TProvider): Promise<ethers.Contract>;
    getAmm(chain: TChain): AMM;
    /**
     * @desc Returns Hop Bridge AMM wrapper Ethers contract instance.
     * @param {Object} chain - Chain model.
     * @param {Object} signer - Ethers signer
     * @returns {Object} Ethers contract instance.
     */
    getAmmWrapper(chain: TChain, signer?: TProvider): Promise<ethers.Contract>;
    /**
     * @desc Returns Hop Bridge Saddle reserve amounts.
     * @param {Object} chain - Chain model.
     * @returns {Array} Array containing reserve amounts for canonical token
     * and hTokens.
     */
    getSaddleSwapReserves(chain?: TChain): Promise<[any, any]>;
    getReservesTotal(chain?: TChain): Promise<any>;
    /**
     * @desc Returns Hop Bridge Saddle Swap LP Token Ethers contract instance.
     * @param {Object} chain - Chain model.
     * @param {Object} signer - Ethers signer
     * @returns {Object} Ethers contract instance.
     */
    getSaddleLpToken(chain: TChain, signer?: TProvider): Promise<Token>;
    /**
     * @desc Sends transaction to add liquidity to AMM.
     * @param {Object} amount0Desired - Amount of token #0 in smallest unit
     * @param {Object} amount1Desired - Amount of token #1 in smallest unit
     * @param {Object} chain - Chain model of desired chain to add liquidity to.
     * @param {Object} options - Method options.
     * @returns {Object} Ethers transaction object.
     */
    addLiquidity(amount0Desired: TAmount, amount1Desired: TAmount, chain?: TChain, options?: Partial<AddLiquidityOptions>): Promise<any>;
    /**
     * @desc Sends transaction to remove liquidity from AMM.
     * @param {Object} liquidityTokenAmount - Amount of LP tokens to burn.
     * @param {Object} chain - Chain model of desired chain to add liquidity to.
     * @param {Object} options - Method options.
     * @returns {Object} Ethers transaction object.
     */
    removeLiquidity(liquidityTokenAmount: TAmount, chain?: TChain, options?: Partial<RemoveLiquidityOptions>): Promise<any>;
    /**
     * @desc Returns the connected signer address.
     * @returns {String} Ethers signer address
     */
    getSignerAddress(): Promise<string>;
    /**
     * @readonly
     * @desc The default deadline to use in seconds.
     * @returns {Number} Deadline in seconds
     */
    get defaultDeadlineSeconds(): number;
    /**
     * @readonly
     * @desc The time slot for the current time.
     * @param {Object} time - Unix timestamp (in seconds) to get the time slot.
     * @returns {Object} Time slot for the given time as BigNumber.
     */
    getTimeSlot(time: TTime): Promise<BigNumber>;
    /**
     * @readonly
     * @desc The challenge period.
     * @returns {Object} The challenge period for the bridge as BigNumber.
     */
    challengePeriod(): Promise<BigNumber>;
    /**
     * @readonly
     * @desc The size of the time slots.
     * @returns {Object} The size of the time slots for the bridge as BigNumber.
     */
    timeSlotSize(): Promise<BigNumber>;
    /**
     * @readonly
     * @desc The amount bonded for a time slot for a bonder.
     * @param {Object} chain - Chain model.
     * @param {Number} timeSlot - Time slot to get.
     * @param {String} bonder - Address of the bonder to check.
     * @returns {Object} Amount bonded for the bonder for the given time slot as BigNumber.
     */
    timeSlotToAmountBonded(timeSlot: TTimeSlot, bonder?: string): Promise<BigNumber>;
    private getTokenIndexes;
    private sendHandler;
    private sendL1ToL2;
    private sendL2ToL1;
    private sendL2ToL2;
    private sendHTokenHandler;
    private calcToHTokenAmount;
    private calcFromHTokenAmount;
    private getRate;
    private getPriceImpact;
    private checkConnectedChain;
    getAmbBridge(chain: TChain): Promise<ethers.Contract>;
    getChainNativeToken(chain: TChain): TokenModel;
    isNativeToken(chain?: TChain): boolean;
    getEthBalance(chain?: TChain, address?: string): Promise<BigNumber>;
    isSupportedAsset(chain: TChain): boolean;
    getBonderAddress(): string;
    shouldAttemptSwap(amountOutMin: BigNumber, deadline: BigNumberish): boolean;
}
export default HopBridge;
//# sourceMappingURL=HopBridge.d.ts.map