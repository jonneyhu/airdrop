"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ethereum_block_by_date_1 = __importDefault(require("ethereum-block-by-date"));
const BaseWatcher_1 = __importDefault(require("./BaseWatcher"));
const ethers_1 = require("ethers");
const models_1 = require("../models");
const luxon_1 = require("luxon");
const abi_1 = require("@ethersproject/abi");
const constants_1 = require("../constants");
const eventTopics_1 = require("../constants/eventTopics");
class L1ToL2Watcher extends BaseWatcher_1.default {
    watch() {
        this.start().catch((err) => this.ee.emit('error', err));
        return this.ee;
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.startBase();
            return this.poll(yield this.pollFn());
        });
    }
    pollFn() {
        return __awaiter(this, void 0, void 0, function* () {
            const destWrapper = yield this.bridge.getAmmWrapper(this.destinationChain);
            const l1Bridge = yield this.bridge.getL1Bridge();
            const sourceTimestamp = this.sourceBlock.timestamp;
            let attemptedSwap = false;
            let amount = ethers_1.BigNumber.from(0);
            for (const log of this.sourceReceipt.logs) {
                if (log.topics[0] === eventTopics_1.transferSentToL2Topic) {
                    const iface = new abi_1.Interface([]);
                    const decodedLog = iface.decodeEventLog(abi_1.EventFragment.from({
                        anonymous: false,
                        inputs: [
                            {
                                indexed: true,
                                internalType: 'uint256',
                                name: 'chainId',
                                type: 'uint256'
                            },
                            {
                                indexed: true,
                                internalType: 'address',
                                name: 'recipient',
                                type: 'address'
                            },
                            {
                                indexed: false,
                                internalType: 'uint256',
                                name: 'amount',
                                type: 'uint256'
                            },
                            {
                                indexed: false,
                                internalType: 'uint256',
                                name: 'amountOutMin',
                                type: 'uint256'
                            },
                            {
                                indexed: false,
                                internalType: 'uint256',
                                name: 'deadline',
                                type: 'uint256'
                            },
                            {
                                indexed: true,
                                internalType: 'address',
                                name: 'relayer',
                                type: 'address'
                            },
                            {
                                indexed: false,
                                internalType: 'uint256',
                                name: 'relayerFee',
                                type: 'uint256'
                            }
                        ],
                        name: 'TransferSentToL2',
                        type: 'event'
                    }), log.data);
                    const amountOutMin = Number(decodedLog.amountOutMin.toString());
                    const deadline = Number(decodedLog.deadline.toString());
                    amount = decodedLog.amount;
                    attemptedSwap = deadline > 0 && amountOutMin > 0;
                }
            }
            const amm = this.bridge.getAmm(this.destinationChain);
            const swap = yield amm.getSaddleSwap();
            const ambBridge = yield this.bridge.getAmbBridge(models_1.Chain.xDai);
            const ammFilter = swap.filters.TokenSwap();
            const ambFilter = {
                address: this.bridge.getL2HopBridgeTokenAddress(this.token, models_1.Chain.xDai)
            };
            const l2BridgeReceiveFilter = {
                topics: [eventTopics_1.transferFromL1CompletedTopic]
            };
            const hToken = yield this.bridge
                .getL2HopToken(this.destinationChain)
                .getErc20();
            const token = yield this.bridge
                .getCanonicalToken(this.destinationChain)
                .getErc20();
            const hTokenFilter = hToken.filters.Transfer();
            const tokenFilter = token.filters.Transfer();
            const recipient = this.sourceTx.from;
            const batchBlocks = 1000;
            let startBlock = -1;
            let endBlock = -1;
            const handleDestTx = (destTx, data = {}) => __awaiter(this, void 0, void 0, function* () {
                if (!sourceTimestamp) {
                    return false;
                }
                if (!destTx) {
                    return false;
                }
                const destBlock = yield this.destinationChain.provider.getBlock(destTx.blockNumber);
                if (!destBlock) {
                    return false;
                }
                const withinAnHour = 60 * 60;
                if (destBlock.timestamp - sourceTimestamp < withinAnHour) {
                    if (yield this.emitDestTxEvent(destTx, data)) {
                        swap.off(ammFilter, handleAmmEvent);
                        ambBridge.off(ambFilter, handleAmmEvent);
                        hToken.off(hTokenFilter, handleHTokenEvent);
                        token.off(tokenFilter, handleTokenEvent);
                        return true;
                    }
                }
                return false;
            });
            const handleAmmEvent = (...args) => __awaiter(this, void 0, void 0, function* () {
                const event = args[args.length - 1];
                if (!event) {
                    return false;
                }
                if (!event.decode) {
                    return false;
                }
                const decodedLog = event.decode(event.data, event.topics);
                if (destWrapper.address.toLowerCase() === decodedLog.buyer.toLowerCase()) {
                    if (amount.toString() !== decodedLog.tokensSold.toString()) {
                        return;
                    }
                    // const destTx = await event.getTransaction()
                    // return handleDestTx(destTx)
                }
                return false;
            });
            const handleTokenEvent = (...args) => __awaiter(this, void 0, void 0, function* () {
                const event = args[args.length - 1];
                if (!event) {
                    return false;
                }
                const decodedLog = event.decode(event.data, event.topics);
                if (decodedLog.from !== destWrapper.address) {
                    return;
                }
                if (decodedLog.to !== recipient) {
                    return;
                }
                console.log('token decoded log', decodedLog);
                const destTx = yield event.getTransaction();
                return handleDestTx(destTx);
            });
            const handleHTokenEvent = (...args) => __awaiter(this, void 0, void 0, function* () {
                const event = args[args.length - 1];
                if (!event) {
                    return false;
                }
                const decodedLog = event.decode(event.data, event.topics);
                if (decodedLog.from !== destWrapper.address) {
                    return;
                }
                if (decodedLog.to !== recipient) {
                    return;
                }
                console.log('hToken decoded log', decodedLog);
                const destTx = yield event.getTransaction();
                return handleDestTx(destTx, {
                    isHTokenTransfer: true
                });
            });
            const handleAmbEvent = (...args) => __awaiter(this, void 0, void 0, function* () {
                const event = args[args.length - 1];
                if (!event) {
                    return false;
                }
                if (!event.getTransactionReceipt) {
                    return false;
                }
                const receipt = yield event.getTransactionReceipt();
                for (const i in receipt.logs) {
                    if (receipt.logs[i].topics[0] === eventTopics_1.tokenTransferTopic) {
                        if (receipt.logs[i].topics[2].includes(this.sourceTx.from.toLowerCase().replace('0x', ''))) {
                            const destTx = yield event.getTransaction();
                            return handleDestTx(destTx);
                        }
                    }
                }
                return false;
            });
            let startBlockNumber = -1;
            return () => __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                if (startBlockNumber === -1) {
                    const blockDater = new ethereum_block_by_date_1.default(this.destinationChain.provider);
                    const date = luxon_1.DateTime.fromSeconds(this.sourceBlock.timestamp).toJSDate();
                    const info = yield blockDater.getDate(date);
                    if (!info) {
                        return false;
                    }
                    startBlockNumber = info.block;
                }
                if (startBlock === -1) {
                    startBlock = startBlockNumber;
                    endBlock = startBlock + batchBlocks;
                }
                else {
                    startBlock = startBlock + batchBlocks;
                    endBlock = startBlock + batchBlocks;
                }
                if (attemptedSwap) {
                    swap.off(ammFilter, handleAmmEvent);
                    swap.on(ammFilter, handleAmmEvent);
                    hToken.off(hTokenFilter, handleHTokenEvent);
                    hToken.on(hTokenFilter, handleHTokenEvent);
                    token.off(tokenFilter, handleTokenEvent);
                    token.on(tokenFilter, handleTokenEvent);
                    const events = ((_a = (yield swap.queryFilter(ammFilter, startBlock, endBlock))) !== null && _a !== void 0 ? _a : []).reverse();
                    if (!events || !events.length) {
                        return false;
                    }
                    for (const event of events) {
                        if (yield handleAmmEvent(event)) {
                            return true;
                        }
                    }
                }
                else if (this.destinationChain.equals(models_1.Chain.Polygon)) {
                    const handleL2BridgeReceiveEvent = (...args) => __awaiter(this, void 0, void 0, function* () {
                        const event = args[args.length - 1];
                        if (event.args.recipient.toLowerCase() === recipient.toLowerCase()) {
                            if (event.args.amount.toString() === amount.toString()) {
                                const destTx = yield event.getTransaction();
                                return handleDestTx(destTx);
                            }
                        }
                        return false;
                    });
                    let provider = this.destinationChain.provider;
                    let url;
                    // archive node provider is needed to read bridge events triggered
                    // by matic validators.
                    if (this.network === constants_1.Network.Mainnet ||
                        this.network === constants_1.Network.Staging) {
                        url = 'https://matic-mainnet-archive-rpc.bwarelabs.com';
                    }
                    else if (this.network === constants_1.Network.Goerli) {
                        url = 'https://matic-testnet-archive-rpc.bwarelabs.com';
                    }
                    if (url) {
                        provider = new ethers_1.providers.StaticJsonRpcProvider(url);
                    }
                    const l2Bridge = yield this.bridge.getL2Bridge(models_1.Chain.Polygon, provider);
                    l2Bridge.off(l2BridgeReceiveFilter, handleL2BridgeReceiveEvent);
                    l2Bridge.on(l2BridgeReceiveFilter, handleL2BridgeReceiveEvent);
                    const events = ((_b = (yield l2Bridge.queryFilter(l2BridgeReceiveFilter, startBlock, endBlock))) !== null && _b !== void 0 ? _b : []).reverse();
                    if (!events || !events.length) {
                        return false;
                    }
                    for (const event of events) {
                        if (yield handleL2BridgeReceiveEvent(event)) {
                            return true;
                        }
                    }
                }
                else if (this.destinationChain.equals(models_1.Chain.Optimism)) {
                    throw new Error('not implemented');
                }
                else if (this.destinationChain.equals(models_1.Chain.Arbitrum)) {
                    throw new Error('not implemented');
                }
                else if (this.destinationChain.equals(models_1.Chain.xDai)) {
                    ambBridge.off(ambFilter, handleAmbEvent);
                    ambBridge.on(ambFilter, handleAmbEvent);
                    const events = ((_c = (yield ambBridge.queryFilter(ambFilter, startBlock, endBlock))) !== null && _c !== void 0 ? _c : []).reverse();
                    if (!events || !events.length) {
                        return false;
                    }
                    for (const event of events) {
                        if (yield handleAmbEvent(event)) {
                            return true;
                        }
                    }
                }
                return false;
            });
        });
    }
}
exports.default = L1ToL2Watcher;
