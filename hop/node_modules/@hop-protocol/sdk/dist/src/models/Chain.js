"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("../constants");
const config_1 = require("../config");
class Chain {
    constructor(name, chainId, provider) {
        this.name = '';
        this.slug = '';
        this.provider = null;
        this.isL1 = false;
        this.name = name;
        this.slug = (name || '').trim().toLowerCase();
        if (this.slug === constants_1.Network.Kovan ||
            this.slug === constants_1.Network.Goerli ||
            this.slug === constants_1.Network.Mainnet ||
            this.slug === constants_1.Network.Staging ||
            this.slug === constants_1.Chain.Ethereum) {
            this.isL1 = true;
            this.slug = constants_1.Chain.Ethereum;
        }
        if (chainId) {
            this.chainId = Number(chainId);
        }
        if (provider) {
            this.provider = provider;
        }
    }
    static fromSlug(slug) {
        return newChain(slug);
    }
    equals(other) {
        return this.slug === other.slug;
    }
    get rpcUrl() {
        var _a, _b;
        return (_b = (_a = this.provider) === null || _a === void 0 ? void 0 : _a.connection) === null || _b === void 0 ? void 0 : _b.url;
    }
}
Chain.Ethereum = newChain(constants_1.Chain.Ethereum);
Chain.Optimism = newChain(constants_1.Chain.Optimism);
Chain.Arbitrum = newChain(constants_1.Chain.Arbitrum);
Chain.xDai = newChain(constants_1.Chain.xDai);
Chain.Polygon = newChain(constants_1.Chain.Polygon);
function newChain(chain) {
    if (chain === constants_1.Network.Mainnet ||
        chain === constants_1.Network.Staging ||
        chain === constants_1.Network.Goerli ||
        chain === constants_1.Network.Kovan) {
        chain = constants_1.Chain.Ethereum;
    }
    if (!config_1.metadata.networks[chain]) {
        throw new Error(`unsupported chain "${chain}"`);
    }
    return new Chain(config_1.metadata.networks[chain].name);
}
exports.default = Chain;
