"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.connectL2Contracts = exports.connectL1Contracts = void 0;
const ethers_1 = require("ethers");
const abstract_provider_1 = require("@ethersproject/abstract-provider");
const contract_artifacts_1 = require("./contract-artifacts");
const contract_deployed_artifacts_1 = require("./contract-deployed-artifacts");
const predeploys_1 = require("./predeploys");
const checkSignerType = (signerOrProvider) => {
    if (!signerOrProvider) {
        throw Error('signerOrProvider argument is undefined');
    }
    if (!abstract_provider_1.Provider.isProvider(signerOrProvider) &&
        !ethers_1.Signer.isSigner(signerOrProvider)) {
        throw Error('signerOrProvider argument is the wrong type');
    }
};
const connectL1Contracts = async (signerOrProvider, network) => {
    checkSignerType(signerOrProvider);
    if (!['mainnet', 'kovan', 'goerli'].includes(network)) {
        throw Error('Must specify network: mainnet, kovan, or goerli.');
    }
    const getEthersContract = (name) => {
        const artifact = contract_deployed_artifacts_1.getDeployedContractArtifact(name, network);
        return new ethers_1.Contract(artifact.address, artifact.abi, signerOrProvider);
    };
    return {
        addressManager: getEthersContract('Lib_AddressManager'),
        canonicalTransactionChain: getEthersContract('CanonicalTransactionChain'),
        stateCommitmentChain: getEthersContract('StateCommitmentChain'),
        xDomainMessengerProxy: getEthersContract('Proxy__L1CrossDomainMessenger'),
        bondManager: getEthersContract('mockBondManager'),
    };
};
exports.connectL1Contracts = connectL1Contracts;
const connectL2Contracts = async (signerOrProvider) => {
    checkSignerType(signerOrProvider);
    const getEthersContract = (name, iface) => {
        const artifact = contract_artifacts_1.getContractArtifact(iface || name);
        const address = predeploys_1.predeploys[name];
        return new ethers_1.Contract(address, artifact.abi, signerOrProvider);
    };
    return {
        eth: getEthersContract('OVM_ETH'),
        xDomainMessenger: getEthersContract('L2CrossDomainMessenger'),
        messagePasser: getEthersContract('OVM_L2ToL1MessagePasser'),
        deployerWhiteList: getEthersContract('OVM_DeployerWhitelist'),
    };
};
exports.connectL2Contracts = connectL2Contracts;
//# sourceMappingURL=connect-contracts.js.map